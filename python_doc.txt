Python Programing:
-----------------
Python is A General purpose high level programing langugae.
Guido Van Rosam was developed the python programing in 1989.But it offically released in 1991.
Why Python programing is popular:
----------------------------------
1.It is very simple and easy

eg:
if "E" in "Easy":
    print("Yes")
output:
Yes
eg:
if "Z" in "Easy":
    print("Yes")                                           
else:
    print("No")

output:
No
2.Python programing used in multiple types of applications
Web applications
Data Science
AI
Testing
Automation
Gameing
Ecommerse
Desktop applications   ....e.t.c
3.Python having consise code
Example:
	Hello world progam using c 
	
#include<stdio.h>
int main()
{
printf("Hello World")
}
Example:
	Hello world progam using python
print("Hello world")

output:
Hello world
4.Python used in Data Analysis
5.Python having large number of libraries support 
Python features:
----------------
1.Python supports functional and procedure oriented features.These features taken from C
programing.
2.Python supports Objective Oriented Programing . These features are taken from C++ programing.
3.Python supports scripting features. These features are taken from shell script programing
4.Python supports modular programing features.These features are taken from modula3.

Python is platform independent :
---------------------------------
We can write python code in any operating system and run any other operating system with out 
modification of the code.

Python Versions:
----------------
The current version of python is 3.12. Upto python 2 version developed based on enhancement
of prrevious version of python.But python 3 developed again from scratch, Python doesn't have 
backward compatablity, it means whatever code we writen in python 2 which is not executed in python 3.
Similarly python 3 code is not executed in python 2.

How to download and install python:
-----------------------------------
1.Go to website https://www.python.org/
2.Click on downloads and click on python for windows

How to open Python:
--------------------
1.Go to windows start
2.Type python it showing results like IDLE (python 3.10)
3.Click to open python IDLE

What is IDLE:
--------------
IDLE stands for Integrated Development Learning Environment.
Wen your beginner to the python if want practice basic examples then go to IDLE

eg:
>>> a=10
>>> b=20
>>> c=a+b
>>> a
10
>>> b
20
>>> c
30
>>> 

eg:
>>> 
>>> x=100
>>> y=2
>>> z=x/y
>>> x
100
>>> y
2
>>> z
50.0

Python IDLE is working based on REPL tool
REPL stands for Read Evaluate Print Loop

It works Read ---->Evaluate----->Print then  agian it expecting new data i.e nothing but loop.

How we can execute python code:
--------------------------------
By using Python IDLE:
---------------------
1.Open python IDLE
2.Go to file and click on New file
3.Write code inside the file
4.Save the file with any name but extenesion with .py eg: xyz.py
5.Go Run and click on Run module.

eg:
a=10
b=20
c=a+b
print(c)
print("Hello")

output:
    30
Hello

Run python code using Text editors:
---------------------------------------
eg:
a=10
b=20
c=a+b
print(c)
print("Hello")

output:
C:\Users\jagan>cd OneDrive
C:\Users\jagan\OneDrive>cd Desktop
C:\Users\jagan\OneDrive\Desktop>cd "python sessions2"
C:\Users\jagan\OneDrive\Desktop\python sessions2>python abc.py
30
Hello

Run python code using IDEs:
----------------------------
IDE stands for Integrated Development Environment
There are so many	 IDEs are 

1.Pycharm
2.Atom
3.Jupiter Note book

e.t.c

Identifiers:
-----------
Identifier is a variable name or function name or class name
Example:
--------
a=10
y=200


def  test():

---

class Student:

----------
--------

Rules to define identifiers:
----------------------------
1.Allowed charcters to define identifiers are A to Z, a to z,0 to 9 and only one special
symbol i.e _ (underscore)
eg:
total=200 ---------------> valid
toTAl=200 --------------->  valid
total_123=400 ------------>Valid
total$123=600------------->Invalid   

2.Identifier should not start with digit.
Example:
 total123=400 ---------------->Valid
 123total=400----------------->Invalid
3.Python is case sensitive programing langugae.

eg:
abc=1000
ABC=2000
print(ABC)
print(abc)

output:
2000
1000

4.There is limit to length of identifier
eg:
a=100
ab=200
abc=300
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=500
5.Reserved words should not used as identifier
Eg:
for =200 -------->Invalid
if=300 ----------->Invalid
6.Diffent types of variable are there
Eg:
x=10 ----------->Normal variable
_x=20 ---------->Protected variable
__x=200 -------->Private variable
__x__=300 -------->Magical method

Reserved words or key words in python:
---------------------------------------
Python having only 33 reserved words

eg:
import keyword
l=keyword.kwlist
print(l)
print(len(l))

output:
['False', 'None', 'True', 'and', 'as', 
'assert', 'break', 'class', 'continue', 
'def', 'del', 'elif', 'else', 'except', 
'finally', 'for', 'from', 'global', 'if',
 'import', 'in', 'is', 'lambda', 'nonlocal', 
 'not', 'or', 'pass', 'raise', 'return', 'try', 
 'while', 'with', 'yield']
 
33

Note:
-----
All reserved words are in lowe case only except True,False and None.

Data Types:
------------
Python is dynamically typed programing langugae.
C and Java programing are statically typed programing langugaes.

tes.c:
------

main()
{
int a=10
str b="Hello"
}

test.py
-------
a=10
b="Hello"
a="Hai"

Note:  "In python everything treated as Object"

Three important functions:
-------------------------
1.type():
--------
type() is inbuilt function of python by using type() to know data type stored in varaible

eg:
a=10
print(a)
print(type(a))

b=10.5
print(b)
print(type(b))

c="Hello"
print(c)
print(type(c))


output:
10
<class 'int'>
10.5
<class 'float'>
Hello
<class 'str'>

2.id()
-------
id() is inbuilt function of python by using id() to know address of object

eg:
a=10
print(a)
print(id(a))

b="Hello"
print(b)
print(id(b))

output:
10
1514522576
Hello
2294219858192


3.print():
----------
print() is inbuilt function of python by using print()  to print the data
eg:
eg:
a=10
print(a)
b="Hello"
print(b)

output:
10
Hello


The following are data types in python 
1.Int
2.float
3.complex
4.bool
5.string
6.list
7.tuple
8.set
9.dict
10.range

1.Integer Data Type:
--------------------
If you want to mention any integer  value we can go for  integer data type

eg:
a=10
print(a)
print(type(a))
print(id(a))

output:
10
<class 'int'>
1514522576

We can represent integer data type in following format

1.a=10                       ------------------------>Decimal format
2.a=0b1010   or a=0B1010      ------------------------>Binary format
eg:
a=0b1010
print(a)
a=0B1010
print(a)

output:
10
10

3.a=0o765   or a=0O765  ------------------------------->Ocatal format
eg:
a=0o765
print(a)
b=0O765
print(b)

output:
501
501

6.a=0xABCD or a=0XABCD ------------------------------------>Hexa decimal format
a=0xA
print(a)
b=0XA
print(b)
output:
10
10

eg:
a=0xABCD
print(a)
b=0XABCD
print(b)

output:
43981
43981

Note:
-----  But internally all represenatations treated as Decimal represenatations only.


Base conversions:
-----------------
To convert one base (one format) to another base (another format) is known as base conversions
The following are base conversions functions
1.bin()  --------------->Given value is converted into Binary
2.oct()  --------------->Given value is converted into Ocatal
3.hex()   --------------->Given value is converted into Hexa decimal

eg:
a=10
print(a)
print(bin(a))
b=0b1010
print(b)
print(oct(b))
c=0o12
print(hex(c))

output:
10
0b1010
10
0o12
0xa

2.Float Data type:
------------------
if you want to mention any flaot point values we can go for flaot data type

eg:
a=12.5
print(a)
print(type(a))

output:
12.5
<class 'float'>

To represent exponential numbers using flaot data type
Eg: 1.2*10^4
Eg:

a=1.2e4
print(a)
print(type(a))
output:
12000.0
<class 'float'>


3.Complex data type:
--------------------
if you want to mention real and imaginary numbers we cango for complex data type
Synatx:
-------
a+bj

eg:
a=20+40j
print(a)
print(type(a))

output:
(20+40j)
<class 'complex'>

4.Boolean data type:
--------------------
True and False are comes under the boolean data type.

True internally treated as 1
False internally treated as 0

eg:
a=True
b=False
print(a)
print(type(a))
print(b)
print(type(b))

output:
True
<class 'bool'>
False
<class 'bool'>

Note:
------
Int,float,complex and boolean data types comes under non itertaion objects.

5.String data type:
-------------------
Any number of sequnce of charcters enclosed with single or double or triple  quotes is known as
string.
Eg:
s='Hello'
s="Hello"
s='''Hello'''
s="""Hello"""
s='H'

eg:
s1="Hello"
print(s1)
print(type(s1))

s2='Hello'
print(s2)
print(type(s2))

output:
Hello
<class 'str'>
Hello
<class 'str'>

eg:
s1="hello
    how 
      are 
        you"
print(s1)

output:
  File "test.py", line 1
    s1="hello
            ^
SyntaxError: EOL while scanning string literal

Note: To define multiline string compulsory use triple quotes .


eg:
s1="""hello
    how 
      are 
        you"""
print(s1)

s2='''hello
    how 
      are 
        you'''
print(s2)

output:
hello
    how
      are
        you
hello
    how
      are
        you


Indexing:
---------

To access charcters in given string we can go for indexing
Python supports two types index

1.Postive index:
--------------
It starts from left to right and starting index value is 0 and end index value is length of string -1

2.Negativeindex:
-----------------
It starts from right to left starting index value is -1 and end index value is - of length of the string.

Syntax:
-------
s[indexvalue]
eg:
s1="ABCDEFGH"
print(s1)
print(len(s1))
print(s1[0])
print(s1[5])
print(s1[7])
#len(s1)-1=8-1=7
print(s1[len(s1)-1])
print(s1[-1])
print(s1[-5])
print(s1[-8])
print(s1[-len(s1)]

output:
ABCDEFGH
8
A
F
H
H
H
D
A

eg:
s1="hello"
print(s1[100])
output:
Traceback (most recent call last):
  File "test.py", line 2, in <module>
    print(s1[100])
IndexError: string index out of range

Note:
If string index value not in range of string index operator raises the IndexError

Slice  Operator:
-----------------
By using slice operator we can access group of charcters from given string

syntax:
-------
s[start index:end index value]
Example:
---------
Given string s="ABCDEFGH"
s[4:8]  here start index is 4 and end index is 8
it slice the given string from start index to end index -1  i.e 4 to 8 -1=  4 to 7
EFGH

eg:
s="ABCDEFGH"
print(s[4:8])

output:
EFGH

eg:
s="ABCDEFGH"
print(s[2:6])

output:
CDEF

Note:
s[:]  here default start index value 0 and default end index value is len(string)

egs="ABCDEFGH"
print(s[:])

output
ABCDEFGH

eg:
s="ABCDEFGH"
print(s[2:])

output:
CDEFGH

eg:
s="ABCDEFGH"
print(s[:5])
output:
ABCDE

eg:
s="ABCDEFGH"
print(s[2:1000])

output:
CDEFGH

Note: Slice operator never raise any error

+ and * operator apply on string:
---------------------------------
+ operator used to concatenate the string
* operator used to repeat the strings specified number of times.

eg:
s1=10
s2=20
print(s1+s2)
s3="Hello"
s4="World"
print(s3+s4)

output:
30
HelloWorld
eg:
s1=10
s2=2
print(s1*s2)
s3="Hello"
s4=4
print(s3*s4)

output:
20
HelloHelloHelloHello

Note:
Integer,Float,Boolean,Complex and String data types  are known as Fundamental data types.

Type casting or Type Cohesion:
-------------------------------
The process of converting one data type to another data type is known as Type casting.
There are 5 Type casting functions are 
1.int()
2.float()
3.complex()
4.bool()
5.str()

1.int():
--------
int() converts any other data type to integer data type
eg:
a=9.2
print(a)
print(type(a))
print(int(a))
print(type(int(a)))

output:
9.2
<class 'float'>
9
<class 'int'>

Note: float data type to integer data type conversions is possible.


eg:
a=True
print(a)
print(type(a))
print(int(a))
print(type(int(a)))

output:
True
<class 'bool'>
1
<class 'int'>
eg:
a=False
print(a)
print(type(a))
print(int(a))
print(type(int(a)))

output:
False
<class 'bool'>
0
<class 'int'>
Note: Boolean data type to integer data type conversions is possible

eg:
a=20+30j
print(a)
print(type(a))
print(int(a))

output;
(20+30j)
<class 'complex'>
Traceback (most recent call last):
  File "test.py", line 4, in <module>
    print(int(a))
TypeError: can't convert complex to int
Note: Complex data typeto integer data type conversions is not possible



eg:
a="Hello"
print(a)
print(int(a))

output:
Hello
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    print(int(a))
ValueError: invalid literal for int() with base 10: 'Hello'

eg:
a="10000"
print(a)
print(type(a))
print(int(a))
print(type(int(a)))

output:
10000
<class 'str'>
10000
<class 'int'>

Note:
----
String data type to integer data conversion is possible but string contains only numeric charcters then
only string converted into integer.

2.float():
---------
float() which converts any other data type to float data type
Eg:
a=20
print(a)
print(type(a))
print(float(a))
print(type(float(a)))

output:
20
<class 'int'>
20.0
<class 'float'>
Note: Integer to float coversion is possible
Eg:
a=True
print(a)
print(type(a))
print(float(a))
print(type(float(a)))
output:
True
<class 'bool'>
1.0
<class 'float'>
Eg:
a=False
print(a)
print(type(a))
print(float(a))
print(type(float(a)))
output:
False
<class 'bool'>
0.0
<class 'float'>
Note : Boolean data to float data conversion is possible

eg:
a=20+6j
print(a)
print(type(a))
print(float(a))
print(type(float(a)))
output:
(20+6j)
<class 'complex'>
Traceback (most recent call last):
  File "test.py", line 4, in <module>
    print(float(a))
TypeError: can't convert complex to float

Note: complex data to float data conversion is not possible
eg:
a="Hello"
print(a)
print(type(a))
print(float(a))
print(type(float(a)))

output:
Hello
<class 'str'>
Traceback (most recent call last):
  File "test.py", line 4, in <module>
    print(float(a))
ValueError: could not convert string to float: 'Hello'
eg:
a="12345"
print(a)
print(type(a))
print(float(a))
print(type(float(a)))

output:
12345
<class 'str'>
12345.0
<class 'float'>

Note: 
----
String data type to float data conversion is possible but string contains only numeric charcters then
only string converted into float.

3.complex():
------------
complex() is convert any other data type to complex data type
Eg:
a=10+20j
b=0+8j
print(a)
print(b)
output:
(10+20j)
8j

Format 1:  complex(x)
------- 
Eg:
a=10
print(a)
print(type(a))
print(complex(a))
print(type(complex(a)))

output:
10
<class 'int'>
(10+0j)
<class 'complex'>

Note: Integer to complex conversion is possible
Eg:
a=10.5
print(a)
print(type(a))
print(complex(a))
print(type(complex(a)))

output:
10.5
<class 'float'>
(10.5+0j)
<class 'complex'>
Note: Float to complex conversion is possibl
Eg:
a=True
print(a)
print(type(a))
print(complex(a))
print(type(complex(a)))

output:
True
<class 'bool'>
(1+0j)
<class 'complex'>
Eg:
a=False
print(a)
print(type(a))
print(complex(a))
print(type(complex(a)))

output:
False
<class 'bool'>
0j
<class 'complex'>
Note: bool to complex conversion is possible
Eg:
a="ABCD"
print(a)
print(type(a))
print(complex(a))
print(type(complex(a)))

output:
ABCD
<class 'str'>
Traceback (most recent call last):
  File "test.py", line 4, in <module>
    print(complex(a))
ValueError: complex() arg is a malformed string
eg:
a="12345"
print(a)
print(type(a))
print(complex(a))
print(type(complex(a)))

output:
12345
<class 'str'>
(12345+0j)
<class 'complex'>

Note:
------
String data type to complex data conversion is possible but string contains only numeric charcters then
only string converted into complex.

Format 2:  complex(x,y)
------- 
Eg:
a=10
b=20
print(a)
print(type(a))
print(b)
print(type(b))
print(complex(a,b))
print(type(complex(a,b)))

output:
10
<class 'int'>
20
<class 'int'>
(10+20j)
<class 'complex'>

Note: integer to complex conversion is possible
eg:
a=10.5
b=20.5
print(a)
print(type(a))
print(b)
print(type(b))
print(complex(a,b))
print(type(complex(a,b)))

output:
10.5
<class 'float'>
20.5
<class 'float'>
(10.5+20.5j)
<class 'complex'>
Note: Float to complex conversion is possible
eg:
a=True
b=True
print(a)
print(type(a))
print(b)
print(type(b))
print(complex(a,b))
print(type(complex(a,b)))
output:
True
<class 'bool'>
True
<class 'bool'>
(1+1j)
<class 'complex'>
Note: Boolean to complex conversion is possible
Eg:
a="Hello"
b="How"
print(a)
print(type(a))
print(b)
print(type(b))
print(complex(a,b))
print(type(complex(a,b)))
output:
Hello
<class 'str'>
How
<class 'str'>
Traceback (most recent call last):
  File "test.py", line 7, in <module>
    print(complex(a,b))
TypeError: complex() can't take second arg if first is a string
eg:
a="1234"
b="5678"
print(a)
print(type(a))
print(b)
print(type(b))
print(complex(a,b))
print(type(complex(a,b)))
output:
1234
<class 'str'>
5678
<class 'str'>
Traceback (most recent call last):
  File "test.py", line 7, in <module>
    print(complex(a,b))
TypeError: complex() can't take second arg if first is a string
eg:
a=1234
b="ABCD"
print(a)
print(type(a))
print(b)
print(type(b))
print(complex(a,b))
print(type(complex(a,b)))
output:
1234
<class 'int'>
ABCD
<class 'str'>
Traceback (most recent call last):
  File "test.py", line 7, in <module>
    print(complex(a,b))
TypeError: complex() second arg can't be a string

NOte: string to complex is not possible

4.bool()
---------
We can convert any data type to boolean data type conversion is possible
Eg:
a=10
b=10.5
c=10+20j
d="Hello"

print(a)
print(type(a))
print(bool(a))
print(type(bool(a)))
print(b)
print(type(b))
print(bool(b))
print(type(bool(b)))
print(c)
print(type(c))
print(bool(c))
print(type(bool(c)))
print(d)
print(type(d))
print(bool(d))
print(type(bool(d)))

output:
10
<class 'int'>
True
<class 'bool'>
10.5
<class 'float'>
True
<class 'bool'>
(10+20j)
<class 'complex'>
True
<class 'bool'>
Hello
<class 'str'>
True
<class 'bool'>

Note:
-----
bool() returns True when data is non zero or non empty string.

Eg:
a=0
b=0.0
c=0+0j
d=""
e=" "

print(a)
print(type(a))
print(bool(a))
print(type(bool(a)))
print(b)
print(type(b))
print(bool(b))
print(type(bool(b)))
print(c)
print(type(c))
print(bool(c))
print(type(bool(c)))
print(d)
print(type(d))
print(bool(d))
print(type(bool(d)))

print(e)
print(type(e))
print(bool(e))
print(type(bool(e)))

outut:
0
<class 'int'>
False
<class 'bool'>
0.0
<class 'float'>
False
<class 'bool'>
0j
<class 'complex'>
False
<class 'bool'>

<class 'str'>
False
<class 'bool'>

<class 'str'>
True
<class 'bool'>

Note:
----
bool() returns False when data is zero, empty string.
5.str()
--------
We can convert any data to string data type is possible
Eg:
a=10
b=10.5
print(a)
print(type(a))
print(str(a))
print(type(str(a)))
print(b)
print(type(b))
print(str(b))
print(type(str(b)))
output:
10
<class 'int'>
10
<class 'str'>
10.5
<class 'float'>
10.5
<class 'str'>
eg:
a=10+8j
print(a)
print(type(a))
print(str(a))
print(type(str(a)))
output:
(10+8j)
<class 'complex'>
(10+8j)
<class 'str'>
Eg:
a=True
b=False
print(a)
print(type(a))
print(str(a))
print(type(str(a)))
print(b)
print(type(b))
print(str(b))
print(type(str(b)))
output:
True
<class 'bool'>
True
<class 'str'>
False
<class 'bool'>
False
<class 'str'>
Note: Any data type to string data type conversion is possible

Immutable and Mutable:
----------------------
Immutable means unable to change and Mutable means change
In python everything treated as an object.Every object holds by varaible when an object
is intiated a unique id genarated . Data type of varaible defined at run time of the progam.
once Object will created we can't change the state of the object is knowns immutable.
eg:
x=10
print(x)
print(id(x))
x=x+1 #x=10+1=11
print(x)
print(id(x))

output:
10
1512818640
11
1512818672
Note: "All fundamental data types are immutable"

Need of immutable:
------------------
Object sharing is possible so that memory utlization improved  then performance will be improved
eg:
a=10
b=20
c=30
d=10
e=20
f=30

print(a)
print(id(a))
print(b)
print(id(b))
print(c)
print(id(c))
print(d)
print(id(d))
print(e)
print(id(e))
print(f)
print(id(f))

output:
10
1512818640
20
1512818960
30
1512819280
10
1512818640
20
1512818960
30
1512819280

eg:
a=10.5
b=20.5
c=30.5
d=10.5
e=20.5
f=30.5

print(a)
print(id(a))
print(b)
print(id(b))
print(c)
print(id(c))
print(d)
print(id(d))
print(e)
print(id(e))
print(f)
print(id(f))

output:
10.5
2785880903968
20.5
2785880903800
30.5
2785880903944
10.5
2785880903968
20.5
2785880903800
30.5
2785880903944

eg:
a=True
b=True
c=False
d=False
e=False
f=True

print(a)
print(id(a))
print(b)
print(id(b))
print(c)
print(id(c))
print(d)
print(id(d))
print(e)
print(id(e))
print(f)
print(id(f))

output:
True
1512337632
True
1512337632
False
1512337664
False
1512337664
False
1512337664
True
1512337632

eg:
a="hello"
b="Hai"
c="hello"
d="Hai"
e="Hai"
f="hello"

print(a)
print(id(a))
print(b)
print(id(b))
print(c)
print(id(c))
print(d)
print(id(d))
print(e)
print(id(e))
print(f)
print(id(f))

output:
hello
2294775275792
Hai
2294775277472
hello
2294775275792
Hai
2294775277472
Hai
2294775277472
hello
2294775275792
eg:
a=20+90j
b=10+8j
c=20+90j
d=10+8j
e=20+90j
f=10+8j

print(a)
print(id(a))
print(b)
print(id(b))
print(c)
print(id(c))
print(d)
print(id(d))
print(e)
print(id(e))
print(f)
print(id(f))
output:
(20+90j)
1875819592816
(10+8j)
1875819592848
(20+90j)
1875819592880
(10+8j)
1875819592912
(20+90j)
1875819592944
(10+8j)
1875819592976

Note:
-----
complex data type is not sharing the object 

6.List Data type:
-----------------
To store group of elements as single entry is known as collections(or array)
Eg:
l=[1,2,3,4,5,6]
print(l)
print(type(l))

output:
[1, 2, 3, 4, 5, 6]
<class 'list'>

Features:
--------
1.In list order is preserved 
eg:
l=["A","B","C","D"]
print(l)
print(type(l))
output:
['A', 'B', 'C', 'D']
<class 'list'>

2.Duplicate elements are allowed
eg:
l=["A","B","C","D","A","B","C","D","A","B","C","D"]
print(l)
print(type(l))

output:
['A', 'B', 'C', 'D', 'A', 'B', 'C', 'D', 'A', 'B', 'C', 'D']
<class 'list'>
3.List allow heterogeneous objects
Eg:
l=["A",1,1.5,True,20+6j]
print(l)
print(type(l))

output:
['A', 1, 1.5, True, (20+6j)]
<class 'list'>
4.List support index and slicing
Eg:
l=["A",1,1.5,True,20+6j,"B","C","D"]
print(l)
print(type(l))
print(l[2])
print(l[2:6])

output:
['A', 1, 1.5, True, (20+6j), 'B', 'C', 'D']
<class 'list'>
1.5
[1.5, True, (20+6j), 'B']

5.List data type is mutable:

Eg:
l=[1,2,3,4]
print(l)
print(id(l))
l.append(8)
print(l)
print(id(l))
l[2]=999
print(l)
print(id(l))
l.remove(4)
print(l)
print(id(l))

output:
[1, 2, 3, 4]
1761936906312
[1, 2, 3, 4, 8]
1761936906312
[1, 2, 999, 4, 8]
1761936906312
[1, 2, 999, 8]
1761936906312

7.Tuple data type:
------------------
1.Tuple is represent ()
2.Tupleis same as list
3.Tuple is immutable
4.Tupleis also known as read only version of list
5.Tuple follow index and slicing
eg:
t=(1,2,3,4,5,6)
print(t)
print(type(t))
output:
(1, 2, 3, 4, 5, 6)
<class 'tuple'>

eg:
t=(1,2,3,4,5,6)
print(t)
print(type(t))
print(t[2])
print(t[4])
print(t[2:5])

output:
(1, 2, 3, 4, 5, 6)
<class 'tuple'>
3
5
(3, 4, 5)
eg:
t=(1,2,3,4,5,6)
print(t)
t[2]=999

output:
(1, 2, 3, 4, 5, 6)
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    t[2]=999
TypeError: 'tuple' object does not support item assignment
Eg:
t=()
print(type(t))
print(t)

output:
<class 'tuple'>
()

eg:
t=(1)
print(type(t))
print(t)

output:
<class 'int'>
1
eg:
t=(1,2)
print(type(t))
print(t)

output:
<class 'tuple'>
(1, 2)
eg:
t=(1,)
print(type(t))
print(t)
output:
<class 'tuple'>
(1,)

8.Set data type:
-----------------
1.Order is not preserved
2.Duplicate elements are not allowed
3.set with elements s={1,2,3} or s=set([1,2,3]) or s=set((1,2,3))
4.empty set s=set()
5.Index and slicing concepts not applicable for set 
6.Hetrogenous objects are allowed
7.Set is mutable data type.

eg:
s={1,2,3,4,5,6,7,8,1,2,3}
print(s)
print(type(s))

output:
{1, 2, 3, 4, 5, 6, 7, 8}
<class 'set'>
eg:
s={1,2,3,4,5,6,7,8,1,2,3}
print(s[5])
output:
Traceback (most recent call last):
  File "test.py", line 2, in <module>
    print(s[5])
TypeError: 'set' object does not support indexing
eg:
s={1,2,3,4,5,6,7,8,1,2,3}
print(s[5:8])
output:
Traceback (most recent call last):
  File "test.py", line 2, in <module>
    print(s[5:8])
TypeError: 'set' object is not subscriptable
eg:
s={1,2,3,4,5,6,7,8,10.5,True,"Hello",2+9j}
print(s)

output:
{1, 2, 3, 4, 5, 6, 7, 8, 10.5, (2+9j), 'Hello'}
eg:
s={}
print(s)
print(type(s))

output:
{}
<class 'dict'>
eg:
s=set()
print(s)
print(type(s))

output:
set()
<class 'set'>

eg:
l=[1,2,3,4,5]
s=set(l)
print(s)
print(type(s))

output:
{1, 2, 3, 4, 5}
<class 'set'>

eg:
s={1,2,3,4}
print(s)
s.add(5)
print(s)
s.remove(2)
print(s)

output:
{1, 2, 3, 4}
{1, 2, 3, 4, 5}
{1, 3, 4, 5}

9.Dictionary:
-------------
To represent key and value pairs we go for dictionary data type.

syntax:
-------
d={key1:value1,key2:value2}
eg:
d={100:"jagan",200:"Raj",300:"Ram"}
print(d)
print(type(d))
output:
{100: 'jagan', 200: 'Raj', 300: 'Ram'}
<class 'dict'>
Features:
---------
1.order is not preserved in dictionary
2.index and slicing concepts not applicable
3.In dictionary duplicate values are allowed but duplicate keys are not allowed.
eg:
d={100:"jagan",200:"Raj",300:"Ram",100:"Mohan",400:"Jagan",500:"Jagan"}
print(d)

output:
{100: 'Mohan', 200: 'Raj', 300: 'Ram', 400: 'Jagan', 500: 'Jagan'}
4.Dictionary mutable data type.
eg:
d={}
print(d)
print(type(d))
d[10]="jagan"
print(d)
d[20]="Mohan"
print(d)
output:
{}
<class 'dict'>
{10: 'jagan'}
{10: 'jagan', 20: 'Mohan'}
5.we can take heterogeneous data for key and values.
eg:
d={1:200,2.5:"ABC",3:True,4:20+9j}
print(d)

output:
{1: 200, 2.5: 'ABC', 3: True, 4: (20+9j)}

10.range():
----------
we can represent  range of sequnce of numbers we ca go for range data type.

Format 1:  range(x)
---------
eg:
r=range(20)
print(r)
print(type(r))

output:
range(0, 20)
<class 'range'>
eg:
r=range(20)
print(r)
print(type(r))
for  x in r:
    print(x)
output:
range(0, 20)
<class 'range'>
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

Format 2:  range(x,y)
---------
eg:
r=range(10,20)
print(r)
print(type(r))
for x in r:
    print(x)
output:
range(10, 20)
<class 'range'>
10
11
12
13
14
15
16
17
18
19
Format 3:  range(x,y,z)
---------
eg:
r=range(10,50,2)
print(r)
for x in r:
    print(x)
output:
range(10, 50, 2)
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
42
44
46
48
Features:
---------
1.Range data type is immutable
2.range(x) he we take x is only integer data type.We can't take x is float
eg:
r=range(10.5)
print(r)

output:
Traceback (most recent call last):
  File "test.py", line 1, in <module>
    r=range(10.5)
TypeError: 'float' object cannot be interpreted as an integer

11.None data type:
------------------
To handle a situation where value is not associate with varaible.
Eg:
x=10
print(x)
x=None
print(x)
print(type(x))

output:
10
None
<class 'NoneType'>

How we can comment the python code:
------------------------------------
Following code is not correct way of commenting the code .

Eg:
print("Hello")
'''print("Hello")
print("Hello")
print("Hello")'''
print("Hello")

output:
Hello
Hello

single line comment:
---------------------
In python code to comment specified line  to use # symbol at startingof the line
eg:
print("Hello")
print("Hello")
#print("Hello")
print("Hello")
print("Hello")

output:
Hello
Hello
Hello
Hello

multiple line comment:
---------------------
Multiple line comment of the code similar to single line comment.
Eg:
print("Hello")
#print("Hello")
#print("Hello")
print("Hello")
print("Hello")

output:
Hello
Hello
Hello


operators:
--------------
The symbol which is responsible to perform some operations is known as operator
1.Arthmatic operators
2.Relational operators
3.Logical operators
4.Bitwise operators
5.Shift operators
6.Assignment operators
7.Equality operators
8.Ternary operators
9.Special operators

1.Arthmatic operators:
-----------------------
'+'symbol which is used for addtion operations 
'-'symbol which is used for subtraction operations
'*'symbol which is used for multiplication operations  
'/'symbol which is used for division operations 
'%'symbol which is used for modulo operations 
'//'symbol which is used for floor division operations 
'**'symbol which is used for power operations 

eg:
a=10
b=20
print("Addtion:",a+b)
print("Subtraction",a-b)
print("Multiplication:",a*b)
print("Division:",a/b)
print("modulo:",a%b)

output:
Addtion: 30
Subtraction -10
Multiplication: 200
Division: 0.5
modulo: 10

eg:
a=4
b=2

print("Division:",a/b)
print("Floor Division:",a//b)

output:
Division: 2.0
Floor Division: 2

eg:
a=4
b=3

print("Division:",a/b)
print("Floor Division:",a//b)

output:
Division: 1.3333333333333333
Floor Division: 1

eg:
a=4.5
b=3.5

print("Division:",a/b)
print("Floor Division:",a//b)

output:
Division: 1.2857142857142858
Floor Division: 1.0
eg:
a=4.5
b=3

print("Division:",a/b)
print("Floor Division:",a//b)

output:
Division: 1.5
Floor Division: 1.0

Note:
----
'/' operator always returns float data only
'//' operator returns integer or float data based given input
consider a//b  if a and b both are integers floor division operator returns integer value.
if a or b  flaot data type floor division returns flaot data type value.

** operator:
------------
Eg:
a=10
b=2
print("a power of b:",a**b)

output:
a power of b: 100
eg:
a=10
b=2.5
print("a power of b:",a**b)
ouput;
a power of b: 316.22776601683796

2.Relational operators:
----------------------
Relational operators are
'<' Lessthan
'<=' Lessthan or equal
'>' Greaterthan
'>=" Greaterthan or equal

Note: Relational operators always returns boolea data type only.
eg:
a=20
b=10
print(a<b)
print(a<=b)
print(a>b)
print(a>=b)

output:
False
False
True
True
eg:
a=10
b=20
print(a<b)
print(a<=b)
print(a>b)
print(a>=b)

output:
True
True
False
False

eg:
False
eg:
a='a' # unicode of 'a' is 97
b="A" #unicode of 'A' is 65

print(a<b)
output:
False

Note:
-----
All alphabets and special charcters internally having a unicode or ASCII code values
(American Standard Code for Information Interchange).


Examples:
--------
 Unicode of 'A' is 65
 Unicode of 'B' is 66
 Unicode of 'a' is 97
 Unicode of 'b' is 98
 
ord():
-----
To get ordinal or unicode value of specified charcter we can go for ord()

eg:
print(ord('A'))
print(ord('B'))
print(ord('a'))
print(ord('b'))

output:
65
66
97
98

chr():
------
To get charcter of specified unicode or ordinal value we can go for chr()
eg:
print(chr(97))
print(chr(98))
print(chr(65))
print(chr(66))
output:
a
b
A
B
eg:
a="hello"
b="Hello"
print(a<b)

output:
False

eg:
a="hellO"
b="hello"
print(a<b)

output:
True

3.Logical operators:
--------------------
Logical operators are and,or,not
Truth table for and operator:
---------------------------
A        B         A and B
---------------------------
True    True       True
True    False 	   False
False   True	   False
False   False      False
------------------------
eg:
a=10
b=20
print( a and b)

output:
20
eg:
a=20
b=10
print( a and b)

output;
10
eg:
a=0
b=10
print( a and b)

ouput:
0
eg:
a=20
b=0
print( a and b)

output:
0

Truth table for or operator:
---------------------------
A        B         A or B
---------------------------
True    True		True
True	False       True
False    True        True
False    False       False
--------------------------
eg:
a=10
b=20
print(a or b)

output:
10
eg:
a=10
b=0
print(a or b)

output:
10

eg;
a=0
b=10
print(a or b)

output:
10
eg:
a=0
b=False
print(a or b)
output:
False

not operator:
-------------
Truth table for not operator
----------------
A         not A
-----------------
True      False
False      True
------------------
eg:
a=10
print(not a)
output:
False

eg:
a=0
print(not a)

output:
True


4.Bitwise operators:
-------------------
To perform operations in bitwise we can go for bitwise operators
& --------> Bitwise and operator
| --------->Bitwise or operator
^ ---------->Bitwise xor operator
~ ----------->Bitwise complement or negation operator

Note: These operators applicable only for integers and boolean data 
eg:
a=4
b=5
print(a & b)

output:
4

eg:
a=4
b=5
print(a | b)

output:
5
eg:
a=4
b=5
print(a ^ b)

output:
1

eg:
a=4
print(~ a)

output:
-5

5.Shift operators:
-------------------
To shift bits either left or right side we can go for shift operators

'<<' It is left shift operator
'>>' It is right shift operator

'<<' It is left shift operator:
------------------------------

eg:
print(10<<2)#40  ------------>101000
print(bin(40))
output:
40
0b101000

'>>' It is right shift operator
---------------------------------
eg:
print(10>>2)
print(bin(2))
output:
2
0b10

6.Assignment operators:
-----------------------
To assign any value to the variable we can go for assignment operator i.e '='
Example:
-------
x=10
a,b,c,d=10,20,30,40
eg:
a=10
b=20
c=30
d=40
print(a)
print(b)
print(c)
print(d)

output:
10
20
30
40

eg:
a,b,c,d=10,20,30,40
print(a)
print(b)
print(c)
print(d)

output:
10
20
30
40

compound assignment operators:
-------------------------------
Assignment operator with some other operator combination is known as 
compound assignment operator.
eg:
x=10
x=x+1  #x=10+1=11
print(x)

output:
11
eg:
x=10
x+=1   #x+=1--------->x=x+1
print(x)

output:
11
Eg:
x=10
x-=1   #x-=1------------->x=x-1-->x=10-1=1
print(x)
output:
9
Note : Increment or decrement operators are not in python.
7.Equality operators:
---------------------
To compare content of the object,
Equality operators are 
1. '==' Equality operator
2.'!='  Mot equal operator
eg:
a=20+30j
b=40+60j
c=20+30j
print(id(a))
print(id(b))
print(id(c))
print(a==b)
print(a==c)
print(a!=b)
print(a!=c)

output:
2265360726960
2265360726992
2265360727024
False
True
True
False
8.Ternary operator:
-------------------
'~'  is uniary operator            Eg: ~4
'+','-','*'e.t.c  are binary operators   eg: a=4+5
synatx:
------
      x= vale1 if condtion value2
Eg:
x=30  if 10<20 else 40
print(x)

output:
30
eg:
x=30  if 10>20 else 40
print(x)

output:
40

eg:
x=10
y=20
r= x if x<y  else y
print(r)

output:
10

eg:
x=20
y=10
r= x if x<y  else y
print(r)

output:
10

9.special operators:
---------------------
special operators are
1.Identity operator
2.Membership operators
1.Identity operator:
--------------------
To compare id's of object we can go for identity operators
identity operators are
        (a). is
		(b). is not
eg:
a=10
b=20
c=30
d=10

print(a)
print(id(a))
print(b)
print(id(b))
print(c)
print(id(c))
print(d)
print(id(d))

print(a is b)
print( a is c)
print( a is d)
print("----------------")
print(a is not b)
print( a is not c)
print( a is not  d)

output:
10
1512818640
20
1512818960
30
1512819280
10
1512818640
False
False
True
----------------
True
True
False

2.Membership operators:
-----------------------
If a particular or group of charcters are a members of given data or not
Membership operators are
	(a). in
	(b). not in
eg:
a=[1,2,3,4,5,6,7,8]
print(a)
print(4 in a)
print(100 in a)

output:
[1, 2, 3, 4, 5, 6, 7, 8]
True
False

eg:
a=[1,2,3,4,5,6,7,8]
print(a)
print(4 not in a)
print(100 not in a)

output:
[1, 2, 3, 4, 5, 6, 7, 8]
False
True

eg:
a="Hello How Are You !"
print(a)
print('e' in a)
print('z' in a)
print('Are' in a)
print('are' in a)

output:
Hello How Are You !
True
False
True
False	

Modules:
--------
Module is nothing but a group of varaibles ,functions and classes saved into a python file
is known as module.
Example:
-------

xyz.py
-------
a=100
b=200
def total(x,y):
    print("Total:",x+y)
def product(x,y):
    print("Product:",x*y)

Here xyz.py is module.

In abc.py file we are importing xyz module .

abc.py
-------
import xyz
print(xyz.a)
print(xyz.b)
xyz.total(10,20)
xyz.product(2,4)

output:
100
200
Total: 30
Product: 8



cde.py it is module
--------
def capital(x):
    print(x.upper())

in pqr.py file importing cde module
pqr.py
-------
import cde
cde.capital("hello how are you !")

output:
C:\Users\jagan\OneDrive\Desktop\python sessions2>python pqr.py
HELLO HOW ARE YOU !


calc.py:   calc.py is module
-------
pi=3.141592653589793238
def total(x,y):
    print("Add:",x+y)
def sub(x,y):
    print("sub:",x-y)
#a=pi.r^2
def area_of_circle(r):
    print("Area of circle:",pi*(r**2))
caluclatin.py
-----------------
import calc
print(calc.pi)
calc.total(10,20)
calc.sub(100,10)
calc.area_of_circle(10)

output:
3.141592653589793
Add: 30
sub: 90
Area of circle: 314.1592653589793

Various ways to import module
-----------------------------
1.import calc
example:
------
import calc
print(calc.pi)
calc.total(10,20)
calc.sub(100,10)
calc.area_of_circle(10)

output:
3.141592653589793
Add: 30
sub: 90
Area of circle: 314.1592653589793

2.from calc import *

Example:
from calc import * 
print(pi)
area_of_circle(10)

output:
3.141592653589793
Area of circle: 314.1592653589793

3.from calc import total, area_of_circle
example:
from calc import total, area_of_circle
total(10,20)
area_of_circle(10)
output:
Add: 30
Area of circle: 314.1592653589793

4.import calc as c
example:
import calc as c
print(c.pi)
c.total(90,10)
output:
3.141592653589793
Add: 100
5.from calc import area_of_circle as area, total as t
example:
from calc import area_of_circle as area, total as t
area(10)
t(10,100)

output:
Area of circle: 314.1592653589793
Add: 110

math module:
------------
we can perform any mathematical operations we can go for math module
Eg:
from math import *
print(sqrt(4))
print(sin(90))

help(modulename):
-----------------
eg:
import math
help(math)

output:
Help on built-in module math:

NAME
    math

DESCRIPTION
    This module is always available.  It provides access to the
    mathematical functions defined by the C standard.

FUNCTIONS
    acos(...)
        acos(x)

        Return the arc cosine (measured in radians) of x.

    acosh(...)
        acosh(x)

        Return the inverse hyperbolic cosine of x.

    asin(...)
        asin(x)

        Return the arc sine (measured in radians) of x.

    asinh(...)
        asinh(x)

        Return the inverse hyperbolic sine of x.

    atan(...)
        atan(x)

        Return the arc tangent (measured in radians) of x.

    atan2(...)
        atan2(y, x)

        Return the arc tangent (measured in radians) of y/x.
        Unlike atan(y/x), the signs of both x and y are considered.

    atanh(...)
        atanh(x)

        Return the inverse hyperbolic tangent of x.

    ceil(...)
        ceil(x)

        Return the ceiling of x as an Integral.
        This is the smallest integer >= x.

    copysign(...)
        copysign(x, y)

        Return a float with the magnitude (absolute value) of x but the sign
        of y. On platforms that support signed zeros, copysign(1.0, -0.0)
        returns -1.0.

    cos(...)
        cos(x)

        Return the cosine of x (measured in radians).

    cosh(...)
        cosh(x)

        Return the hyperbolic cosine of x.

    degrees(...)
        degrees(x)

        Convert angle x from radians to degrees.

    erf(...)
        erf(x)

        Error function at x.

    erfc(...)
        erfc(x)

        Complementary error function at x.

    exp(...)
        exp(x)

        Return e raised to the power of x.

    expm1(...)
        expm1(x)

        Return exp(x)-1.
        This function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.

    fabs(...)
        fabs(x)

        Return the absolute value of the float x.

    factorial(...)
        factorial(x) -> Integral

        Find x!. Raise a ValueError if x is negative or non-integral.

    floor(...)
        floor(x)

        Return the floor of x as an Integral.
        This is the largest integer <= x.

    fmod(...)
        fmod(x, y)

        Return fmod(x, y), according to platform C.  x % y may differ.

    frexp(...)
        frexp(x)

        Return the mantissa and exponent of x, as pair (m, e).
        m is a float and e is an int, such that x = m * 2.**e.
        If x is 0, m and e are both 0.  Else 0.5 <= abs(m) < 1.0.

    fsum(...)
        fsum(iterable)

        Return an accurate floating point sum of values in the iterable.
        Assumes IEEE-754 floating point arithmetic.

    gamma(...)
        gamma(x)

        Gamma function at x.

    gcd(...)
        gcd(x, y) -> int
        greatest common divisor of x and y

    hypot(...)
        hypot(x, y)

        Return the Euclidean distance, sqrt(x*x + y*y).

    isclose(...)
        isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) -> bool

        Determine whether two floating point numbers are close in value.

           rel_tol
               maximum difference for being considered "close", relative to the
               magnitude of the input values
            abs_tol
               maximum difference for being considered "close", regardless of the
               magnitude of the input values

        Return True if a is close in value to b, and False otherwise.

        For the values to be considered close, the difference between them
        must be smaller than at least one of the tolerances.

        -inf, inf and NaN behave similarly to the IEEE 754 Standard.  That
        is, NaN is not close to anything, even itself.  inf and -inf are
        only close to themselves.

    isfinite(...)
        isfinite(x) -> bool

        Return True if x is neither an infinity nor a NaN, and False otherwise.

    isinf(...)
        isinf(x) -> bool

        Return True if x is a positive or negative infinity, and False otherwise.

    isnan(...)
        isnan(x) -> bool

        Return True if x is a NaN (not a number), and False otherwise.

    ldexp(...)
        ldexp(x, i)

        Return x * (2**i).

    lgamma(...)
        lgamma(x)

        Natural logarithm of absolute value of Gamma function at x.

    log(...)
        log(x[, base])

        Return the logarithm of x to the given base.
        If the base not specified, returns the natural logarithm (base e) of x.

    log10(...)
        log10(x)

        Return the base 10 logarithm of x.

    log1p(...)
        log1p(x)

        Return the natural logarithm of 1+x (base e).
        The result is computed in a way which is accurate for x near zero.

    log2(...)
        log2(x)

        Return the base 2 logarithm of x.

    modf(...)
        modf(x)

        Return the fractional and integer parts of x.  Both results carry the sign
        of x and are floats.

    pow(...)
        pow(x, y)

        Return x**y (x to the power of y).

    radians(...)
        radians(x)

        Convert angle x from degrees to radians.

    sin(...)
        sin(x)

        Return the sine of x (measured in radians).

    sinh(...)
        sinh(x)

        Return the hyperbolic sine of x.

    sqrt(...)
        sqrt(x)

        Return the square root of x.

    tan(...)
        tan(x)

        Return the tangent of x (measured in radians).

    tanh(...)
        tanh(x)

        Return the hyperbolic tangent of x.

    trunc(...)
        trunc(x:Real) -> Integral

        Truncates x to the nearest Integral toward 0. Uses the __trunc__ magic method.

DATA
    e = 2.718281828459045
    inf = inf
    nan = nan
    pi = 3.141592653589793
    tau = 6.283185307179586

FILE
    (built-in)

Input and Output statements:
---------------------------
Input statements:
------------------
To take data from end user (comand prompt) we can go for input statements
example:
a=input()
print(a)
output:
C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
6
6

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
10
10
eg:
a=input("Eneter some number:")
print(a)
output:
C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Eneter some number:10
10

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Eneter some number:20
20

Note:  whate ever data enterd by end user is always string data only.
----
eg:
a=input("Eneter some number:")
print(a)
print(type(a))

output:
C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Eneter some number:10
10
<class 'str'>

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Eneter some number:10.5
10.5
<class 'str'>

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Eneter some number:10+20j
10+20j
<class 'str'>

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Eneter some number:True
True
<class 'str'>

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Eneter some number:"Hello"
"Hello"
<class 'str'>

C:\Users\jagan\OneDrive\Desktop\python sessions2>

Eg:
x=input("Enter First Number :")
y=input("Enetr Second  Number:")
print("Add:",x+y)

output:
Enter First Number :10
Enetr Second  Number:20
Add: 1020

eg:
x=int(input("Enter First Number :"))
y=int(input("Enetr Second  Number:"))
print("Add:",x+y)

output:
Enter First Number :10
Enetr Second  Number:20
Add: 30

eval():
------
eval() function is type casting function which is automatically type caste appropriate data  which taken from input statements
Eg
x=eval(input("Enter marks:"))
print(x)
print(type(x))

output:
Enter marks:10
10
<class 'int'>

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter marks:10.5
10.5
<class 'float'>

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter marks:"Hello"
Hello
<class 'str'>

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter marks:True
True
<class 'bool'>

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter marks:20+9j
(20+9j)
<class 'complex'>
C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter marks:[1,2,3,4]
[1, 2, 3, 4]
<class 'list'>

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter marks:(1,2,3,4)
(1, 2, 3, 4)
<class 'tuple'>

command line arguments:
------------------------
The arguments which are passed from command prompt are known as command line arguments

In python sys is a predefined module in that module there is one varaible i.e argv.
In argv varaible we can store all command line arguments.
Eg:
from sys import argv 
print(argv)
print(type(argv))

output:
['test.py', '1', '2', '3', '4', '5', '6']
<class 'list'>

Eg:
from sys import argv 
print(argv)
print(type(argv))
print(argv[0])
print(argv[1:])

output:
['test.py', '1', '2', '3', '4', '5', '6']
<class 'list'>
test.py
['1', '2', '3', '4', '5', '6']
Eg:
from sys import argv
args=argv[1:]
print(args)
total=0
for x in args:
    total=total+int(x)
print("Total:",total)

output:
['1', '2', '3', '4', '5', '6']
Total: 21


output statements:
------------------
 To rint data in output we can go for output statements
 
print():
---------
 Empty print() used to print empty line
Eg:
print("Hello")
print("Good morning")

output:
Hello
Good morning

eg:
print("Hello")
print()
print("Good morning")

output:
Hello

Good morning

print('string'):
----------------
print("hello")
output:
hello

sep=''
------
In output more than one values are separated by default with space
Eg:
a,b,c=10,20,30
print(a,b,c)
print(a,b,c, sep=',')
print(a,b,c, sep='-')

output:
10 20 30
10,20,30
10-20-30

end=''
-------
eg:
print("Hello")
print("how")
print("are")
print("you")

output:
Hello
how
are
you

eg:
print("Hello",end=' ')
print("how",end=' ')
print("are",end=' ')
print("you")


output:
Hello how are you

.format()
--------
eg:
name="jagan"
sid=222
branch="EEE"
print("Name:",name,"Student Id:",sid,"Branch:",branch)
print("Name:{}  Student id:{}   Branch:{} ".format(name,sid,branch))

output:
Name: jagan Student Id: 222 Branch: EEE
Name:jagan  Student id:222   Branch:EEE

eg:
name=input("Entere student name:")
sid=input("Enter student id:")
branch=input("Enter branch:")
print("Student name is {}  id number {} belongs {} branch".format(name,sid,branch))

output:
Entere student name:"jagan"
Enter student id:222
Enter branch:"EEE"
Student name is "jagan"  id number 222 belongs "EEE" branch


Flow control:
--------------
At run time in which order statement going to be executed is decided by flow control.

Indentation:
------------
Indentation in python refers to  tab space
To represent block of code with indentation

example:
-------
main()
{
printf("Hello")
if (10<20);
{ printf("Yes")
}
else;
{
printf("No")
}

}
Example:
--------
print("Hello")
if(10<20):
	print("Yes")
else:
	print("No")
	
eg:
print("Hello")
if(10<20):
print("Yes")
else:
	print("No")
    
output:
  File "test.py", line 3
    print("Yes")
        ^
IndentationError: expected an indented block	
eg:
print("Hello")
if(10<20):
    print("Yes")
else:
	print("No")
    
output:
Hello
Yes
eg:
print("Hello")
if(10>20):
    print("Yes")
else:
	print("No")
    
output:
Hello
No
eg:
print("Hello")
if(10<20):
    print("Yes")
else:
	print("No")
    
print("How are you")

output:
Hello
Yes
How are you

1.conditional statements:
--------------------------
conditional statements help you to make a decision based on certain condtions.
These condtions are specified by a set of conditional statements having Boolean expressions
which are evaluated to Boolean value of true or false.

condtional statements are 
1.if
2.if else
3.if elif else
4.if elif elif.........else

eg:
#WAP to find larger number in given two numbers
n1=int(input("Enter First number:"))
n2=int(input("Enter Second number:"))
if n1>n2:
    print("larger number :",n1)
else:
    print("larger number :",n2)
output:
Enter First number:10
Enter Second number:20
larger number : 20

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter First number:20
Enter Second number:10
larger number : 20

eg:
#WAP to find larger number in given three numbers
n1=int(input("Enter First number:"))
n2=int(input("Enter Second number"))
n3=int(input("Enter Third number:"))

if  n1>n2  and n1>n3:
    print("large number is :",n1)
elif  n2>n3:
    print("large number is :",n2)
else:
    print("large number is :",n3)
 
output:
Enter First number:30
Enter Second number20
Enter Third number:10
large number is : 30

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter First number:20
Enter Second number30
Enter Third number:10
large number is : 30

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter First number:10
Enter Second number20
Enter Third number:30
large number is : 30 
eg:
n=int(input("Enter a number:"))
if 1<=n<=100:
    print('Yes')
else:
    print("No")

output:
Enter a number:1
Yes

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter a number:100
Yes

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter a number:50
Yes

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter a number:101
No       
eg:
n=int(input("Enter a number:"))
if n in range(1,101):
    print('Yes')
else:
    print("No")
output:
Enter a number:1
Yes

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter a number:100
Yes

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter a number:50
Yes

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter a number:101
No

eg:
n=int(input("Enter a number:"))
if n%2==0:  
    print("Even number")
else:
    print("Odd number")
eg:
Enter a number:10
Even number

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter a number:11
Odd number

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter a number:12
Even number

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter a number:12
Even number
eg:
list_of_states=['AP','TS','TN','KA','KL']
print(list_of_states)
state=input("Enter your state name:")

if state  in list_of_states:
    if state=="AP":
        print("AMRAVATHI")
    elif state=="TS":
        print("HYD")
    elif state=="TN":
        print("CHEN")
    elif state=="KA":
        print("BEN")
    else:
        print("Tiruanthapur")
else:
    print("Your enterd state info not found")
output:
['AP', 'TS', 'TN', 'KA', 'KL']
Enter your state name:"MR"
Your enterd state info not found


C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
['AP', 'TS', 'TN', 'KA', 'KL']
Enter your state name:AP
AMRAVATHI

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
['AP', 'TS', 'TN', 'KA', 'KL']
Enter your state name:KA
BEN

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
['AP', 'TS', 'TN', 'KA', 'KL']
Enter your state name:TN
CHEN

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
['AP', 'TS', 'TN', 'KA', 'KL']
Enter your state name:KL
Tiruanthapur

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
['AP', 'TS', 'TN', 'KA', 'KL']
Enter your state name:TS
HYD    

2.Iterative statements:
------------------------
	1.for loop
	2.while loop

1.for loop:
-----------
 If you have any sequnce of elements (e.g: list,tuple,set,dic,range) to perform any 
 operation on each elements in given sequnce then we can go for loop.
syntax:
--------
for temp_variable in sequnce:
	body
eg:
for  x  in  ["A","B","C","D"]:
    print(x)
output:
A
B
C
D
eg:
for n in range(1,10):
    print(n)
output:
1
2
3
4
5
6
7
8
9
eg:
for n in range(1,10):
    print("number is {}".format(n))
output:
number is 1
number is 2
number is 3
number is 4
number is 5
number is 6
number is 7
number is 8
number is 9

eg:
for n in range(1,10):
    print(" squre of number  {}  is {}".format(n,n**2))
output:
 squre of number  1  is 1
 squre of number  2  is 4
 squre of number  3  is 9
 squre of number  4  is 16
 squre of number  5  is 25
 squre of number  6  is 36
 squre of number  7  is 49
 squre of number  8  is 64
 squre of number  9  is 81
eg:
n=range(1,50)
print(n)
even_list=[]
odd_list=[]
for x in n:
    if x%2==0:
        even_list.append(x)
    else:
        odd_list.append(x)
print("Even Numbers:",even_list) 
print("Odd Numbers:",odd_list)      

output:
range(1, 50)
Even Numbers: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48]
Odd Numbers: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49]   

2.while loop:
------------
 To perform some operations on sequnce based on some condtion
Eg:
n=5
total=0
i=1
while i<=n:             #1<=5        #2<=5        #3<=5       #4<=5        #5<=5          #6<=5 -->False
    print(i)            #1           #2           #3          #4           #5
    total=total+i       #total=0+1=1 #total=1+2=3 #total=3+3=6#total=6+4=10#total=10+5=15
    i=i+1               #i=1+1=2     #i=2+1=3     #i=3+1=4    #i=4+1=5     #i=5+1=6

print("Total:",total)
output:
-----
1
2
3
4
5
Total: 15
eg:
s="Hello"
n=len(s)-1#n=5-1=4
i=0
while i<=n: 
    print(s[i])
    i=i+1
output:
H
e
l
l
o

eg:
l=list(range(1,11)) #[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(l)
n=len(l)-1
print(n)
even_list=[]
odd_list=[]
i=0
while i<=n:
    if l[i]%2==0:
        even_list.append(l[i])
    else:
        odd_list.append(l[i])
    i=i+1
print("Even Numbers :",even_list)
print("odd Numbers:",odd_list)

output:
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
9
Even Numbers : [2, 4, 6, 8, 10]
odd Numbers: [1, 3, 5, 7, 9]

     
infinite loops:
---------------
Because of programmers mistake the condtions of loops always True. Such type of loops
keep on iteraring these types of loops are known as infinite loops. 
eg:
n=5
total=0
i=1
while i<=n:
    print(i)
    i=i-1
output:
C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
1
0
-1
-2
-3
-4
-5
-6
-7
-8
-9
Traceback (most recent call last):
  File "test.py", line 5, in <module>
    print(i)
KeyboardInterrupt

3.Transfer statements:
----------------------
1.break
2.continue

1.break:
---------
Break the loop based on some condtion.
eg:
cart=[10,20,30,40,500,300,200,150,100]
for item  in cart:
    print("Price:",item)
output:
Price: 10
Price: 20
Price: 30
Price: 40
Price: 500
Price: 300
Price: 200
Price: 150
Price: 100
eg:
cart=[10,20,30,40,500,300,200,150,100]
for item  in cart:
    print("Price:",item)
    if item >= 500:  
        print("Item {} requires insurance".format(item))
        break
print("End")       

output:
Price: 10
Price: 20
Price: 30
Price: 40
Price: 500
Item 500 requires insurance
End

2.continue
----------
Skip the current iteration based on some condtion
eg:
cart=[10,20,30,40,500,700,300,200,150,800,100]
for item  in cart:
    
    if item >= 500:  
        print("Item {} requires insurance".format(item))
        continue
    print("Price:",item)
print("End")       

output:
Price: 10
Price: 20
Price: 30
Price: 40
Item 500 requires insurance
Item 700 requires insurance
Price: 300
Price: 200
Price: 150
Item 800 requires insurance
Price: 100
End

pass:
-----
if required some empty block we write pass statement
eg:
for x in range (10):


output:

              ^
SyntaxError: unexpected EOF while parsing         
eg:
for x in range (10):
    pass

del statement:
------------
del is key word in python to delete object

eg:
x=10
print(x)
del x 
print(x)

output:
10
Traceback (most recent call last):
  File "test.py", line 4, in <module>
    print(x)
NameError: name 'x' is not defined


None:
-----
if want to delete only object but don't want delete varaible we can go for None.

eg:
x=10
print(x)
x=None
print(x)

output:
10
None

Strings:
-------
Any sequnce of charcters within either single quotes or double or triple quotes is considerd as
as string.


Accessing charcters of the string:
----------------------------------
1.By using indexing
2.By using slice operator

1.By using indexing:
---------------------
Python supports two types index 
+ve index means left to right (Forward direction)
-ve index means right to left (Reverse direction)
eg:
s="ABCDEFG"
print(s[3])
print(s[-2])

output:
D
F
eg:
s="ABCDEFG"
print(s[300])

output:
Traceback (most recent call last):
  File "test.py", line 2, in <module>
    print(s[300])
IndexError: string index out of range
  
eg:
s="ABCDEFG"
for x in s:
    print(x)
output:
A
B
C
D
E
F
G
eg:
s="ABCDEFG"
i=0
for x in s:
    print("{} postive index {}and negative index{} ".format(x,i,i-len(s)))
    i=i+1
output:
A postive index 0and negative index-7
B postive index 1and negative index-6
C postive index 2and negative index-5
D postive index 3and negative index-4
E postive index 4and negative index-3
F postive index 5and negative index-2
G postive index 6and negative index-1


2.Accessing charcters by using slice operator:
-----------------------------------------------
syntax:  s[beginindex:endindex:step]
------
beginindex:  from where we have to consider substring
-----------
endindex:  we have to terminate sub string  at endindex -1
---------
step:    incremented value
------

eg:
s="ABCDEFG"
b=len(s)-1
print(b)
print(s[b])

output:
6
G

Behaviour of slice operator:
----------------------------
s[beginindex:endindex:step]
step value is either + ve or -ve 

if step value is + ve then it is in forward direction and we can consider start index to end index -1
if step value is -ve then it is in reverse direction and we can consider   start index to  end index +1


in forward direction:
---------------------
step value is +ve
default beginindex value is 0
default end index value is endindex -1

in backward direction:
---------------------
step value is -ve
default beginindex value is -1
default end index value is -(length of string +1)
eg:
s="abcdefghij"
print(s)
print(len(s))

output:
abcdefghij
10

eg:
s="abcdefghij"
print(s)
print(s[1:6:2])

print(s[2:7:2])

output:
abcdefghij
bdf
ceg
eg:
s="abcdefghij"
print(s)
print(s[::])
output:
abcdefghij
abcdefghij

eg:
s="abcdefghij"
print(s)
print(s[::-1])

output:
abcdefghij
jihgfedcba

eg:
s="abcdefghij"
print(s)
print(s[3:7:-1])

output:
abcdefghij
eg:
s="abcdefghij"
print(s)
print(s[7:4:-1])

output:
abcdefghij
hgf

eg:
s="abcdefghij"
print(s)
print(s[8:3:-2])

output:
abcdefghij
ige
eg:
s="abcdefghij"
print(s)
print(s[1:1000:1])

output:
abcdefghij
bcdefghij


Mathematical operators on string:
---------------------------------
1.+ operator for string concatination
2.* operator for string repetition
eg:
print("Hello"+"world")
print("Hello"*4)

output:
Helloworld
HelloHelloHelloHello

len():
-----
len() returns the number of charcters in given string 
eg:
s="ABCDEFGH"
print(s)
print(len(s))

output:
ABCDEFGH
8

checking membeship:
--------------------

s="Hello"
print("e" in s)
print("z" in s)
print("e" not  in s)
print("z" not in s)

output:
True
False
False
True
eg:
s=input("Enter main string:")
subs=input("Enter substring:")
if subs in s:
    print(subs,"is present in main string")
else:
    print(subs,"is not present in main string")
output:
Enter main string:Hello World
Enter substring:World
World is present in main string

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter main string:Hello World
Enter substring:Hai
Hai is not present in main string

Removing spaces:
---------------
1.rstrip() --------> To remove spaces at right hand side
2.lstrip() ----------->To remove spaceleft hand side
3.strip() --------------->To remove spaces both sides
Eg:
city=input("Enter city name:")
if city =="Hyd":
    print("Avaialable")
else:
     print("Not Avaialable")
output:
C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter city name:Hyd
Avaialable

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter city name:  Hyd
Not Avaialable

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter city name:Hyd
Not Avaialable

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter city name:  Hyd
Not Avaialable  

eg:
city=input("Enter city name:")
if city.lstrip() =="Hyd":
    print("Avaialable")
else:
     print("Not Avaialable")
output:
Enter city name:    Hyd
Avaialable
eg:
city=input("Enter city name:")
if city.rstrip() =="Hyd":
    print("Avaialable")
else:
     print("Not Avaialable")
output:
Enter city name:Hyd
Avaialable
eg:
city=input("Enter city name:")
if city.strip() =="Hyd":
    print("Avaialable")
else:
     print("Not Avaialable")
output:
Enter city name:    Hyd
Avaialable

count():
--------
eg:
s="ABCDEAB"
print(s.count("A"))
print(s.count("B"))
print(s.count("C"))
print(s.count("D"))

output:
2
2
1
1

eg:
s="ABCDEABCABABAAAA"
print(s.count("ABC"))
print(s.count("AB"))
print(s.count("AA"))
output:
2
4
2


replace():
----------
eg:
s="ABCDABCDAAABBB"
s2=s.replace("A","z")
print(s)
print(s2)


output:
ABCDABCDAAABBB
zBCDzBCDzzzBBB

eg:
s="ABCDABCDAAABBB"
s2=s.replace("ABC","123")
print(s)
print(s2)
output:
ABCDABCDAAABBB
123D123DAAABBB
eg:
s="ABCDABCDAAABBB"
s2=s.replace("ABC","23")
print(s)
print(s2)


output:
ABCDABCDAAABBB
23D23DAAABBB

split():
---------
eg:
s="Hello How Are You"
s1=s.split()
print(s1)
print(type(s1))

output:
['Hello', 'How', 'Are', 'You']
<class 'list'>

eg:
s="Hello-How-Are-You"
s1=s.split('-')
print(s1)
print(type(s1))

output:
['Hello', 'How', 'Are', 'You']
<class 'list'>
eg:
s="Hello-How-Are-You"
s1=s.split('-')
print(s1)
print(type(s1))

for x in s1:
    print(x)
output:
['Hello', 'How', 'Are', 'You']
<class 'list'>
Hello
How
Are
You
eg:
s="Hello-How-Are-You"
s1=s.split('-')
print(s1)
print(type(s1))

for x in s1:
    for y  in x:
        print(y)
output:
['Hello', 'How', 'Are', 'You']
<class 'list'>
H
e
l
l
o
H
o
w
A
r
e
Y
o
u   

join():
-------
eg:
s="Hello-How-Are-You"
s1=s.split('-')
print(s1)#['Hello', 'How', 'Are', 'You']
s3=''.join(s1)
print(s3)
print(type(s3))

output:
['Hello', 'How', 'Are', 'You']
HelloHowAreYou
<class 'str'>
eg:
s="Hello-How-Are-You"
s1=s.split('-')
print(s1)#['Hello', 'How', 'Are', 'You']
s3=' '.join(s1)
print(s3)
print(type(s3))

output:
['Hello', 'How', 'Are', 'You']
Hello How Are You
<class 'str'>
eg:
['Hello', 'How', 'Are', 'You']
Hello#How#Are#You
<class 'str'>

changeing case of the string:
-----------------------------
1.upper() ------------>To convert all charcters to uppercase
2.lower() ------------->To convert all charcters to lowercase
3.swapcase() ---------->all lowecase to uppercase and uppercase to lowercase
4.title() -------------->First charcter in every word is uppercase and remaing are lower case
5.captitalize()--------->Only first charcter is upper remaing are lower
eg:
s="hello world"
print(s.upper())
s1="HELLO WORLD"
print(s1.lower())
s2="HeLlO WOrlD"
print(s2.swapcase())
s3="python programing is very easy"
print(s3.title())
print(s3.capitalize())

output:
HELLO WORLD
hello world
hElLo woRLd
Python Programing Is Very Easy
Python programing is very easy
eg:
username=input("Enter username:")
passwd=input("Enter password:")
if username=="jagan" and passwd=="mohan222":
    print("Valid user")
else:
    print("Invalid user")
output:
Enter username:jagan
Enter password:mohan222
Valid user

C:\Users\jagan\OneDrive\Desktop\python sessions2>
C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter username:JAGAN
Enter password:mohan222
Invalid user

eg:
username=input("Enter username:")
passwd=input("Enter password:")
if username.lower()=="jagan" and passwd=="mohan222":
    print("Valid user")
else:
    print("Invalid user")
output:
Enter username:jagan
Enter password:mohan222
Valid user

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter username:JAGAN
Enter password:mohan222
Valid user

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter username:JaGAn
Enter password:mohan222
Valid user

Checking starting and ending part of the string:
-----------------------------------------------
1.s.startswith(substring)
2.s.endswith(substring)
eg:
s="Python is Easy"
print(s.startswith("P"))
print(s.startswith("Z"))
print(s.startswith("Python"))
print(s.startswith("Java"))
print(s.endswith("y"))
print(s.endswith("Easy"))
print(s.endswith("Dificult"))

output:
True
False
True
False
True
True
False

To check type of charcters present in string:
-----------------------------------------------
1.isalnum()
------------
"ABCDEFGHijkl12345"--->Alphabet,numbers------>alphanumericdata------>isalnum()

True-------->A to Z, a to z and 0 to 9
eg:
s="12345"
print(s.isalnum())
s1="ABcd"
print(s1.isalnum())
s2="ABcd123"
print(s2.isalnum())
s4="#$%"
print(s4.isalnum())

outut:
True
True
True
False
eg:
s2="ABcd123#&*"
print(s2.isalnum())
output:
False

2.isalpha():
-----------
"A to Z , a to z"---------->True
eg:
s1="ABCdefgh"
print(s1.isalpha())
s2="ABCdefgh123"
print(s2.isalpha())
output:
True
False

3.islower():
-----------
eg:
s1="abcd"
print(s1.islower())
s2="ABCD"
print(s2.islower())

output:
True
False
4.isupper():
------------
eg:
s1="ABCD"
print(s1.isupper())
s2="abcd"
print(s2.isupper())
output:
True
False

5.isdigit():
-------------
eg:
s1="12345678"
print(s1.isdigit())
s2="abcd1234567"
print(s2.isdigit())
output:
True
False
6.istitle():
----------
eg:
s1="Hello world"
print(s1.istitle())
s2="Hello World"
print(s2.istitle())
output:
False
True
7.isspace():
-----------
eg:
s1="ABCd  ABCD"
print(s1.isspace())
s2="     "
print(s2.isspace())

output:
False
True

eg:
s=input("Enter data:")
if s.isalnum():
    if s.isalpha():
        if s.islower():
            print("It is lower case data")
        else:
            print("It is upper case data ")
    elif s.isdigit():
        print("It is digits")
    else:
        print("It is apha numeric")

elif s.isspace():
    print("It is space data")
else:
    print("It is apecial charcter  or comination of alphanumeric and special charcters")
    
eg;
s=input("Enter data:") #ABCD
if s.isalnum():
    if s.isalpha():
        if s.islower():
            print("It is lower case data")
        else:
            print("It is upper case data ")
    elif s.isdigit():
        print("It is digits")
    else:
        print("It is apha numeric")

elif s.isspace():
    print("It is space data")
else:
    print("It is apecial charcter  or comination of alphanumeric and special charcters")
    
output:
Enter data:ABCDEF  $$$
It is apecial charcter  or comination of alphanumeric and special charcters

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter data:
It is space data

C:\Users\jagan\OneDrive\Desktop\python sessions2>
C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter data:ABCDabcd123
It is apha numeric

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter data:123456
It is digits

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter data:abcd
It is lower case data
C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter data:ABCD
It is upper case data
eg:
s="Hello world"
print(s)
print(s[::-1])

output:
Hello world
dlrow olleH
eg;
s="Hello world"
r=reversed(s)
print(r)
print(type(r))
l=[]
for x in r:
    print(x)
    l.append(x)
print(l)
a="".join(l)
print(a)

output:
<reversed object at 0x000002A7CB0DE7B8>
<class 'reversed'>
d
l
r
o
w

o
l
l
e
H
['d', 'l', 'r', 'o', 'w', ' ', 'o', 'l', 'l', 'e', 'H']
dlrow olleH

eg:
s="Hello"
output=""
i=len(s)-1#5-1=4
while i>=0:
    output=output+s[i]#""+"o"="o"  #"o"+"l"="ol"#"ol"+"l"="oll"#"oll"+"e"="olle"#"olle"+"H"="olleH"
    i=i-1
print(output)
output:
olleH
eg:
s="ABDDDC"
output=''
for ch in s:
    if ch not in output:
        output=output+ch
print(output)
output:
ABDC

List Data type:
---------------
1.Insertion order is preserved
2.Duplicate values are allowed
3.Hetrogenous data is allowed
4.Lis Dynamic
5.List is mutable
6.List represent using [ ]

creation of list:
-----------------
1.To create empty list:
------------------------
eg:
l=[]
print(l)
print(type(l))
l2=list()
print(l2)
print(type(l2))

output;
[]
<class 'list'>
[]
<class 'list'>

2.To create a list with specified elements:
--------------------------------------------
eg:
l=[1,2,3,4,5]

print(l)

output:
[1, 2, 3, 4, 5]

3.To create list by dynaic input:
---------------------------------
eg:
l=eval(input("Enter a list:"))
print(l)

output:
Enter a list:[1,2,3,4,5,6]
[1, 2, 3, 4, 5, 6]

4.By using list()
--------------------
eg:
l=list(("A","B","C"))
print(l)
output:
['A', 'B', 'C']
5.By using split():
--------------------
eg:
s="Hello world How are you".split()
print(s)
output:
['Hello', 'world', 'How', 'are', 'you']

Accessing data from list:
--------------------------
1.Index
2.slice
eg:
l=["a","b","c","d"]
print(l[2])
print(l[2:100])

output:
c
['c', 'd']

Traversing of List:
---------------------
We can access elements of list sequencely
eg:
l=["a","b","c","d"]
for x in l:
    print(x)
output:
a
b
c
d
eg:
l=["a","b","c","d"]
i=0
while i<len(l):
    print(l[i])
    i=i+1
output:
a
b
c
d

+ and * operators on string:
----------------------------
eg:
l1=["A","B","C","D"]
l2=[1,2,3,4]
print(l1+l2)
print(l1*4)

output:
['A', 'B', 'C', 'D', 1, 2, 3, 4]
['A', 'B', 'C', 'D', 'A', 'B', 'C', 'D', 'A', 'B', 'C', 'D', 'A', 'B', 'C', 'D']

== and !=
---------
eg:
l1=["A","B","C","D"]
l2=["A","B","C","D"]
l3=["A","C","B","D"]
l4=["A","B","C","D","E"]
print(l1==l2)
print(l1==l3)
print(l1==l4)

print(l1!=l2)
print(l1!=l3)
print(l1!=l4)

output:
True
False
False
False
True
True

membership operators:
---------------------
eg:
l1=["A","B","C","D"]
print("C" in l1)
print("Z" in l1)

print("C" not in l1)
print("Z" not in l1)

output:
True
False
False
True

Methods in list:
---------------
len():
------
eg:
l1=["A","B","C","D"]
print(len(l1))
output:
4

sorted():
--------
eg:
l1=[50,40,20,70,100,200,150,120,10]
print(l1)
print(sorted(l1))
print(sorted(l1,reverse=True))
output:
[50, 40, 20, 70, 100, 200, 150, 120, 10]
[10, 20, 40, 50, 70, 100, 120, 150, 200]
[200, 150, 120, 100, 70, 50, 40, 20, 10]


count():
-----
l1=[50,40,20,70,100,200,150,120,10,50,10,1,2,10,50]
print(l1)

print(l1.count(50))
print(l1.count(10))

output:
[50, 40, 20, 70, 100, 200, 150, 120, 10, 50, 10, 1, 2, 10, 50]
3
3

index():
-------
eg;
l1=[50,40,20,70,100,200]
print(l1)
print(l1[3])
print(l1.index(70))
output:
[50, 40, 20, 70, 100, 200]
70
3
eg:
l1=[50,40,20,70,100,200]
print(l1)

print(l1.index(700))

output:
[50, 40, 20, 70, 100, 200]
Traceback (most recent call last):
  File "test.py", line 4, in <module>
    print(l1.index(700))
ValueError: 700 is not in list
eg:
l=[10,20,30,40,50]
print(l)
x=int(input("enter element find it's index:"))
if x in l:
    print("{} present at index {}".format(x,l.index(x)))
else:
    print("Element not found")
output:
[10, 20, 30, 40, 50]
enter element find it's index:20
20 present at index 1

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
[10, 20, 30, 40, 50]
enter element find it's index:50
50 present at index 4

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
[10, 20, 30, 40, 50]
enter element find it's index:100
Element not found

append():
---------
eg:
--
l=[]
print(l)
l.append("A")
print(l)
l.append("B")
print(l)
l.append("C")
print(l)
output:
[]
['A']
['A', 'B']
['A', 'B', 'C']

eg:
l=[]
for x in range(1,100):
    if x%10==0:
        l.append(x)
print(l)
output:
[10, 20, 30, 40, 50, 60, 70, 80, 90]

insert():
---------
synatx:  l.insert(index,element)
-------

eg:
l=[10,20,30,40,50,60]
print(l)
l.append(70)
print(l)
l.insert(2,200)
print(l)
output:
[10, 20, 30, 40, 50, 60]
[10, 20, 30, 40, 50, 60, 70]
[10, 20, 200, 30, 40, 50, 60, 70]

extend():
---------
eg:
l1=[10,20,30,40,50,60]
l2=[1,2,3,4,5,6,7,8,9]
print(l1)
print(l2)
print(l1+l2)
print(l1)
print(l2)
l1.extend(l2)
print(l1)
print(l2)
output:
[10, 20, 30, 40, 50, 60]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
[10, 20, 30, 40, 50, 60, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[10, 20, 30, 40, 50, 60]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
[10, 20, 30, 40, 50, 60, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 5, 6, 7, 8, 9]

remove():
--------
eg:
l1=[10,20,30,40,50,60]
print(l1)
l1.remove(50)
print(l1)
output:
[10, 20, 30, 40, 50, 60]
[10, 20, 30, 40, 60]

pop():
------
eg:
l1=[10,20,30,40,50,60]
print(l1)
l1.remove(50)
print(l1)
print(l1.pop())
print(l1)
output:
[10, 20, 30, 40, 50, 60]
[10, 20, 30, 40, 60]
60
[10, 20, 30, 40]

pop(index):
----------
eg:
l1=[10,20,30,40,50,60]
print(l1)
print(l1.pop(2))
print(l1)
output:
[10, 20, 30, 40, 50, 60]
30
[10, 20, 40, 50, 60]
eg:
l1=[10,20,30,40,50,60]
print(l1)
print(l1.pop(200))
print(l1)
output:
[10, 20, 30, 40, 50, 60]
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    print(l1.pop(200))
IndexError: pop index out of range

clear():
--------
eg:
l1=[10,20,30,40,50,60]
print(l1)
l1.clear()
print(l1)
output:
[10, 20, 30, 40, 50, 60]
[]

ordering elements of given list:
----------------------------------
reverse():
---------
eg:
l1=[10,20,30,40,50,60]
print(l1)
l1.reverse()
print(l1)
output:
[10, 20, 30, 40, 50, 60]
[60, 50, 40, 30, 20, 10]

sort():
-------
eg:
l1=[10,100,200,150,50,40,70,80]
print(l1)
l1.sort()
print(l1)
output:
[10, 100, 200, 150, 50, 40, 70, 80]
[10, 40, 50, 70, 80, 100, 150, 200]
eg:
l1=["A","D","C","B"]
print(l1)
l1.sort()
print(l1)
output:
['A', 'D', 'C', 'B']
['A', 'B', 'C', 'D']

Aliasing and clonening:
-----------------------
Aliasing means to create new refference varaible to existing object.
clonening menas creating exactly duplicate independent object.
eg:
l1=[1,2,3,4,5,6,7,8,9]
l2=l1
l3=l2
print(l1)
print(id(l1))
print(l2)
print(id(l2))
print(l3)
print(id(l3))

output:
[1, 2, 3, 4, 5, 6, 7, 8, 9]
2566040754248
[1, 2, 3, 4, 5, 6, 7, 8, 9]
2566040754248
[1, 2, 3, 4, 5, 6, 7, 8, 9]
2566040754248

eg:
l1=[1,2,3,4,5,6,7,8,9]
l2=l1
l3=l2
print(l1)
print(id(l1))
print(l2)
print(id(l2))
print(l3)
print(id(l3))

l1[2]=200
print(l1)
print(l2)
print(l3)


output:
[1, 2, 3, 4, 5, 6, 7, 8, 9]
2368966858824
[1, 2, 3, 4, 5, 6, 7, 8, 9]
2368966858824
[1, 2, 3, 4, 5, 6, 7, 8, 9]
2368966858824
[1, 2, 200, 4, 5, 6, 7, 8, 9]
[1, 2, 200, 4, 5, 6, 7, 8, 9]
[1, 2, 200, 4, 5, 6, 7, 8, 9]


Two ways are there to create cloned object:
--------------------------------------------
1.By using slice operator:
--------------------------------
eg:
l1=[1,2,3,4,5,6,7,8,9]
l2=l1[::]
print(l1)
print(id(l1))
print(l2)
print(id(l2))

output:
[1, 2, 3, 4, 5, 6, 7, 8, 9]
2915271088200
[1, 2, 3, 4, 5, 6, 7, 8, 9]
2915271089224
eg:
l1=[1,2,3,4,5,6,7,8,9]
l2=l1[::]
print(l1)
print(id(l1))
print(l2)
print(id(l2))

l1[2]=200
print(l1)
print(l2)
output:
[1, 2, 3, 4, 5, 6, 7, 8, 9]
3148204906568
[1, 2, 3, 4, 5, 6, 7, 8, 9]
3148204907592
[1, 2, 200, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 5, 6, 7, 8, 9]

2.By using copy():
-----------------
eg:
l1=[1,2,3,4,5,6,7,8,9]
l2=l1.copy()
print(l1)
print(id(l1))
print(l2)
print(id(l2))

l1[2]=200
print(l1)
print(l2)

output:
[1, 2, 3, 4, 5, 6, 7, 8, 9]
1937885075528
[1, 2, 3, 4, 5, 6, 7, 8, 9]
1937885076552
[1, 2, 200, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 5, 6, 7, 8, 9]

List comprehention:
--------------------
eg:
l=[]
for x in range(1,11):
    l.append(x*x)
print(l)
output:
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
eg:
l=[x*x  for x  in range(1,11)]
print(l)
output:
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
eg:
print([x*x  for x  in range(1,11)])
output:
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

eg:
l=[x for x in range(1,11) if x%2==0]
print(l)
output:
[2, 4, 6, 8, 10]
eg:
s="the quick brown fox jumping over a lazy dog".split()
print(s)
l=[[word.upper(),len(word)]for word in s]
print(l)

output;
['the', 'quick', 'brown', 'fox', 'jumping', 'over', 'a', 'lazy', 'dog']
[['THE', 3], ['QUICK', 5], ['BROWN', 5], ['FOX', 3], ['JUMPING', 7], ['OVER', 4], ['A', 1], ['LAZY', 4], ['DOG', 3]]

eg:
v=['a','e','i','o','u']
w=input("Enter word:")
r=[]
for ch in w:
    if ch in v:
        if ch not in r:
            r.append(ch)
    
print(r)
print("Number of vowels in given word:",len(r))
output:
Enter word:elephant
['e', 'a']
Number of vowels in given word: 2

tuple data type:
---------------
1.tuple preserved order.
2.tuple allows the duplicates
3.tuple allows heterogeneous data
4.index and slice are applicable
5.tuple immutable
6.tuple represent ()

creation of tuple:
------------------
1.single value:
---------------
eg:
t=10
print(t)
print(type(t))
output:
10
<class 'int'>
eg:
t=(10)
print(t)
print(type(t))

output:
10
<class 'int'>
eg:
t=(10,20,30,40)
print(t)
print(type(t))

output:
(10, 20, 30, 40)
<class 'tuple'>
eg:
t=(10,)
print(t)
print(type(t))

output:
(10,)
<class 'tuple'>
2.
t=(10,20,30,40)
print(t)
print(type(t))

output:
(10, 20, 30, 40)
<class 'tuple'>
eg:
t=10,20,30,40
print(t)
print(type(t))

output:
(10, 20, 30, 40)
<class 'tuple'>

3.tuple()
l=[1,2,3,4,5,6]
print(l)
t=tuple(l)
print(t)
output:
[1, 2, 3, 4, 5, 6]
(1, 2, 3, 4, 5, 6)
4.eval():
---------
eg:
t=eval(input("Enter tuple:"))
print(t)
print(type(t))
output:
Enter tuple:(1,2,3,4,5,6)
(1, 2, 3, 4, 5, 6)
<class 'tuple'>

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter tuple:[1,2,3,4,5,6]
[1, 2, 3, 4, 5, 6]
<class 'list'>

index and slice operator:
-------------------------
eg:
t=(10,20,30,40,50)
print(t)
print(t[2])
print(t[-1])
output:
(10, 20, 30, 40, 50)
30
50
eg:
t=(10,20,30,40,50)
print(t)
print(t[2:6])
output:
(10, 20, 30, 40, 50)
(30, 40, 50)


len():
-------
eg:
t=(10,20,30,40,50)
print(t)
print(len(t))
output:
(10, 20, 30, 40, 50)
5
index():
-------
eg:
t=(10,20,30,40,50)
print(t)
print(t.index(20))
print(t.index(40))
output:
(10, 20, 30, 40, 50)
1
3
reverse():
---------
eg:
t=(10,20,30,40,50)
print(t)
t.reverse()
output:
(10, 20, 30, 40, 50)
Traceback (most recent call last):
  File "test.py", line 4, in <module>
    t.reverse()
AttributeError: 'tuple' object has no attribute 'reverse'

reversed():
----------
eg:
t1=(10,20,30,40)
print(t1)
print(id(t1))
t2=reversed(t1)
print(t2)
print(id(t2))
output:
(10, 20, 30, 40)
2333891937368
<reversed object at 0x0000021F66E3EB00>
2333893454592
eg:
t1=(10,20,30,40)
print(t1)
print(id(t1))
t2=reversed(t1)
print(t2)
print(id(t2))
for x in t2:
    print(x)
output:
(10, 20, 30, 40)
1792941868120
<reversed object at 0x000001A173B0EB00>
1792942336768
40
30
20
10
eg:
t1=(10,20,30,40)
print(t1)
print(id(t1))
t1.sort()
output:
(10, 20, 30, 40)
3216395651096
Traceback (most recent call last):
  File "test.py", line 4, in <module>
    t1.sort()
AttributeError: 'tuple' object has no attribute 'sort'
eg:
t1=(10,40,20,15)
print(t1)
print(id(t1))
t2=sorted(t1)
print(t2)
output:
(10, 40, 20, 15)
1284025795672
[10, 15, 20, 40]

min() and max():
----------------
eg:
t1=(10,40,20,15)
print(t1)
print(min(t1))
print(max(t1))
output:
(10, 40, 20, 15)
10
40

eg:
t1=(10,40,20,15)
print(t1)
t1[2]=200
print(t1)
output:
(10, 40, 20, 15)
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    t1[2]=200
TypeError: 'tuple' object does not support item assignment

Note: Elements of  manuplication is not suported because tuple data type is immutable


packing and unpacking of tuple:
-------------------------------
Eg:
a=10
b=20
c=30
d=40
t=(a,b,c,d)
print(t)

output:
(10, 20, 30, 40)
eg:
t=(10, 20, 30, 40)
a,b,c,d=t
print(a)
print(b)
print(c)
print(d)

output:
10
20
30
40
eg:
t=(10, 20, 30, 40)
a,b=t
print(a)
print(b)
output:
Traceback (most recent call last):
  File "test.py", line 2, in <module>
    a,b=t
ValueError: too many values to unpack (expected 2)

eg:
t=(10, 20, 30, 40)
a,*b=t
print(a)
print(b)
output:
10
[20, 30, 40]

tuple comprehention:
-------------------
eg:
t=(x for x in range(1,10))
print(t)
print(type(t))

output:
<generator object <genexpr> at 0x00000238D4833A40>
<class 'generator'>
eg:
t=(x for x in range(1,10))
print(t)
print(type(t))
for x in t:
    print(x)
output:
<generator object <genexpr> at 0x000002C303703A40>
<class 'generator'>
1
2
3
4
5
6
7
8
9
eg:
t=(x for x in range(1,1000000))
print(t)
print(type(t))
for x in t:
    print(x)


Set data type:
----------------
1.duplicates are not allowed
2.order is not preserved
3.index and slice not applicable
4.set represent by {1,2,3}
5.set is mutable
6.Hetrogenous data allowed
7.union,intersection and difference operation we can perform 

creation of set:
-----------------
1.empty set 
eg:
s={}
print(s)
print(type(s))
output:
{}
<class 'dict'>

eg:
s=set()
print(s)
print(type(s))
output:
set()
<class 'set'>
2.
s={1,2,3,4,2,3,4}
print(s)
print(type(s))

output:
{1, 2, 3, 4}
<class 'set'>
3.By using set()
l=[1,2,3,4,5]
s=set(l)
print(s)
output:
{1, 2, 3, 4, 5}
4.eval()
eg:
s=eval(input("Enter set:"))
print(s)
output:
Enter set:{1,2,3,4}
{1, 2, 3, 4}


len():
------
eg:
s={1, 2, 3, 4}
print(len(s))
output:
4

add():
-----
s={1, 2, 3, 4}
print(s)
s.add(60)
print(s)
s.add(50)
print(s)
s.add(40)
print(s)
s.add("A")
print(s)

output:
{1, 2, 3, 4}
{1, 2, 3, 4, 60}
{1, 2, 3, 4, 50, 60}
{1, 2, 3, 4, 40, 50, 60}
{1, 2, 3, 4, 40, 50, 'A', 60}

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
{1, 2, 3, 4}
{1, 2, 3, 4, 60}
{1, 2, 3, 4, 50, 60}
{1, 2, 3, 4, 40, 50, 60}
{1, 2, 3, 4, 40, 'A', 50, 60}

remove():
--------
eg:
s={1, 2, 3, 4, 40, 'A', 50, 60}
print(s)
s.remove(40)
print(s)
output:
{1, 2, 3, 4, 40, 50, 'A', 60}
{1, 2, 3, 4, 50, 'A', 60}

update:
-------
eg:
l=[1,2,3,4]
s={5,6,7,8}
s.update(l)
print(s)
output:
{1, 2, 3, 4, 5, 6, 7, 8}

discard():
----------
eg:
s={10,20,30,40,50}
print(s)
s.remove(40)
print(s)
s.remove(100)
print(s)

output:
{40, 10, 50, 20, 30}
{10, 50, 20, 30}
Traceback (most recent call last):
  File "test.py", line 5, in <module>
    s.remove(100)
KeyError: 100
eg:
s={10,20,30,40,50}
print(s)
s.remove(40)
print(s)
s.discard(20)
print(s)
s.discard(120)
print(s)

output:
{40, 10, 50, 20, 30}
{10, 50, 20, 30}
{10, 50, 30}
{10, 50, 30}

pop():
------
eg:
s={10,20,30,40,50}
print(s)
print(s.pop())
print(s.pop())
print(s.pop())
print(s)
output:
{40, 10, 50, 20, 30}
40
10
50
{20, 30}

clear():
--------
eg:
s={10,20,30,40,50}
print(s)
s.clear()
print(s)
output:
{40, 10, 50, 20, 30}
set()

set operations:
-----------------
1.union():
-----------
eg:
s1={10,20,30,40}
s2={30,40,50,60}
s3=s1.union(s2)
print(s3)

s3=s1 | s2
print(s3)

output:
{40, 10, 50, 20, 60, 30}
{40, 10, 50, 20, 60, 30}
2.intersection():
-----------------
eg:
s1={10,20,30,40}
s2={30,40,50,60}
s3=s1.intersection(s2)
print(s3)
s3=s1 & s2
print(s3)
output:
{40, 30}
{40, 30}

3.difference:
--------------
eg:
s1={10,20,30,40}
s2={30,40,50,60}
s3=s1.difference(s2)
print(s3)
s3=s1-s2
print(s3)
output:
{10, 20}
{10, 20}
4.symmetrc difference:
---------------------
eg:
s1={10,20,30,40}
s2={30,40,50,60}
s3=s1.symmetric_difference(s2)
print(s3)
s3=s1^s2
print(s3)

output:
{10, 50, 20, 60}
{10, 50, 20, 60}
set comprehention:
------------------
eg:
s1={1,2,3,4,5,6}
print(s1)
s2=set()
for x in s1:
    s2.add(x*x)
print(s2)
output:
{1, 2, 3, 4, 5, 6}
{1, 4, 36, 9, 16, 25}
eg:
s1={1,2,3,4,5,6}
s={x*x for x in s1}
print(s)
output:
{1, 4, 36, 9, 16, 25}

Dict data type:
---------------
if want to represent any key and its value pairs we can go for dict data type.

1.dict key and value pairs
2.Duplicate key are not allowed and values duplicated
3.Insertion order not preserved
4.index and slice not applicable
5.Hetrogenious allowed
6.dic is mutable

creation of dictionary:
------------------------
1.empty dict
eg:
d={}
print(d)
print(type(d))
d1=dict()
print(d1)
print(type(d1))

output:
{}
<class 'dict'>
{}
<class 'dict'>
2.
d={1:"A",2:"B",3:"C",4:"C"}
print(d)
output:
{1: 'A', 2: 'B', 3: 'C', 4: 'C'}
3.dict()
eg:
l=[(1,"A"),(2,"B"),(3,"C")]
d=dict(l)
print(d)
output:
{1: 'A', 2: 'B', 3: 'C'}
4.eval()
eg:
d=eval(input("Enter dict:"))
print(d)
output:
Enter dict:{1:"A",2:"B",3:"C"}
{1: 'A', 2: 'B', 3: 'C'}

Accessing data from the dictionary:
------------------------------------
eg:
d={100:"Ram",200:"Raj",300:"Basha"}
print(d)
print(d[100])
print(d[300])

output:
{100: 'Ram', 200: 'Raj', 300: 'Basha'}
Ram
Basha
eg:
d={100:"Ram",200:"Raj",300:"Basha"}
print(d)
print(d[400])
output
{100: 'Ram', 200: 'Raj', 300: 'Basha'}
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    print(d[400])
KeyError: 400
eg:
d={100:"Ram",200:"Raj",300:"Basha"}
print(d)
key=int(input("Enter Key:"))
if key in d:
    print("Its value is :",d[key])
else:
    print("Key not found")
output:
{100: 'Ram', 200: 'Raj', 300: 'Basha'}
Enter Key:200
Its value is : Raj

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
{100: 'Ram', 200: 'Raj', 300: 'Basha'}
Enter Key:100
Its value is : Ram

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
{100: 'Ram', 200: 'Raj', 300: 'Basha'}
Enter Key:400
Key not found

add or update dictionary:
-------------------------
eg:
d={100:"Ram",200:"Raj",300:"Basha"}
print(d)
d[100]="Raj"
print(d)
d[600]="Basha"
print(d)
d[200]="Ganesh"
print(d)
output:
{100: 'Ram', 200: 'Raj', 300: 'Basha'}
{100: 'Raj', 200: 'Raj', 300: 'Basha'}
{100: 'Raj', 200: 'Raj', 300: 'Basha', 600: 'Basha'}
{100: 'Raj', 200: 'Ganesh', 300: 'Basha', 600: 'Basha'}
eg:
d={100:"Ram",200:"Raj",300:"Basha"}
print(d)
del d[100]
print(d)

output:
{100: 'Ram', 200: 'Raj', 300: 'Basha'}
{200: 'Raj', 300: 'Basha'}

eg:
d={100:"Ram",200:"Raj",300:"Basha"}
print(d)
del d[100],d[200]
print(d)
output:
{100: 'Ram', 200: 'Raj', 300: 'Basha'}
{300: 'Basha'}
eg:
n=int(input("Enter number of students:"))
d={}
for x in range(n):
    name=input("Enter Name:")
    marks=int(input("Enter marks:"))
    d[name]=marks
print(d)
for k,v in d.items():
    print("Student Name:{} Marks:{}".format(k,v))
outut:
Enter number of students:4
Enter Name:Ram
Enter marks:70
Enter Name:Basha
Enter marks:80
Enter Name:Raj
Enter marks:90
Enter Name:Khan
Enter marks:60
{'Ram': 70, 'Basha': 80, 'Raj': 90, 'Khan': 60}
Student Name:Ram Marks:70
Student Name:Basha Marks:80
Student Name:Raj Marks:90
Student Name:Khan Marks:60

methods in dictionary:
----------------------
len():
-----
eg:
d={'Ram': 70, 'Basha': 80, 'Raj': 90, 'Khan': 60}
print(d)
print(len(d))

output:
{'Ram': 70, 'Basha': 80, 'Raj': 90, 'Khan': 60}
4

d.get(key):
-----------
eg:
d={1:"A",2:"B",3:"C"}
print(d)
print(d[2])
print(d.get(2))
output:
{1: 'A', 2: 'B', 3: 'C'}
B
B
eg:
d={1:"A",2:"B",3:"C"}
print(d)
print(d[200])
output:
{1: 'A', 2: 'B', 3: 'C'}
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    print(d[200])
KeyError: 200
eg:
d={1:"A",2:"B",3:"C"}
print(d)
print(d.get(200))
output:
{1: 'A', 2: 'B', 3: 'C'}
None

d.get(key,defaultvalue):
---------------------
eg:
d={1:"A",2:"B",3:"C"}
print(d)
print(d.get(2,"Key Not found"))
print(d.get(200,"Key Not found"))

output:
{1: 'A', 2: 'B', 3: 'C'}
B
Key Not found

d.update(d2):
-------------
eg:
d1={1:"A",2:"B",3:"C"}
d2={11:"AA",22:"BB",33:"CC"}
d1.update(d2)
print(d1)
print(d2)

output:
{1: 'A', 2: 'B', 3: 'C', 11: 'AA', 22: 'BB', 33: 'CC'}
{11: 'AA', 22: 'BB', 33: 'CC'}

keys():
-------
eg:
d1={1:"A",2:"B",3:"C"}
print(d1)
k=d1.keys()
print(k)
for k in d1.keys():
    print(k)
output:
{1: 'A', 2: 'B', 3: 'C'}
dict_keys([1, 2, 3])
1
2
3
values():
---------
eg:
d1={1:"A",2:"B",3:"C"}
print(d1)
k=d1.values()
print(k)
for k in d1.values():
    print(k)
output:
{1: 'A', 2: 'B', 3: 'C'}
dict_values(['A', 'B', 'C'])
A
B
C

items():
--------
d1={1:"A",2:"B",3:"C"}
print(d1)
i=d1.items()
print(i)

for k,v in d1.items():
    print(k,"-----",v)
output:
{1: 'A', 2: 'B', 3: 'C'}
dict_items([(1, 'A'), (2, 'B'), (3, 'C')])
1 ----- A
2 ----- B
3 ----- C

pop(key)
--------
eg:
d1={1: 'A', 2: 'B', 3: 'C'}
print(d1)
print(d1.pop(2))
print(d1)
output:
{1: 'A', 2: 'B', 3: 'C'}
B
{1: 'A', 3: 'C'}
eg:
d1={1: 'A', 2: 'B', 3: 'C'}
print(d1)
print(d1.pop(200))
print(d1)
output:
{1: 'A', 2: 'B', 3: 'C'}
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    print(d1.pop(200))
KeyError: 200

pop(key,defaultvalue)
---------------------
eg:
d1={1: 'A', 2: 'B', 3: 'C'}
print(d1)
print(d1.pop(2,"This key not found in d1"))
print(d1)
print(d1.pop(200,"This key not found in d1"))
output:
{1: 'A', 2: 'B', 3: 'C'}
B
This key not found in d1

d.popitem():
------------
eg:
d1={1: 'A', 2: 'B', 3: 'C'}
print(d1)
print(d1.popitem())
print(d1)
print(d1.popitem())
print(d1)

output:
{1: 'A', 2: 'B', 3: 'C'}
(3, 'C')
{1: 'A', 2: 'B'}
(2, 'B')
{1: 'A'}

d1.clear():
-----------
eg:
d1={1: 'A', 2: 'B', 3: 'C'}
print(d1)
d1.clear()
print(d1)

output:
{1: 'A', 2: 'B', 3: 'C'}
{}

d1.setdefault(k,v):
--------------------
eg:
d1={1: 'A', 2: 'B', 3: 'C'}
print(d1)
d1[2]="X"
print(d1)
d1[40]="X"
print(d1)

output:
{1: 'A', 2: 'B', 3: 'C'}
{1: 'A', 2: 'X', 3: 'C'}
{1: 'A', 2: 'X', 3: 'C', 40: 'X'}

eg:
d1={1: 'A', 2: 'B', 3: 'C'}
print(d1)
d1.setdefault(2,"X")
print(d1)
d1.setdefault(200,"X")
print(d1)
output;
{1: 'A', 2: 'B', 3: 'C'}
{1: 'A', 2: 'B', 3: 'C'}
{1: 'A', 2: 'B', 3: 'C', 200: 'X'}

eg:
#input: Word="Hello"
#output: {"H":1,"e":1","l":2,"o":1}
word=input("Enter a word:")
d={}#{"H":1,"e":1,"l":2,"o":1}
for ch in word:          #H                                 #e                            #l                           #l
    d[ch]=d.get(ch,0)+1  #d["H"]=d.get("H",0)+1=0+1=d["H"]=1#d["e"]=d.get('e',0)+1=0+1=1  #d['l']=d.get('l',0)+1=0+1=1 #d['l']=d.get('l',0)+1=1+1=2
print(d)   

output:
Enter a word:Hello
{'H': 1, 'e': 1, 'l': 2, 'o': 1}

C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Enter a word:Apple
{'A': 1, 'p': 2, 'l': 1, 'e': 1}
eg:
d={"A":1,"B":2,"C":3}
print(d)
total=0
for k, v in d.items():
    total=total+v
print(total)
output:
{'A': 1, 'B': 2, 'C': 3}
6
eg:
n=int(input("Enter number of students:"))
d={}
for x in range(n):
    name=input("Enter Name:")
    marks=int(input("Enter marks:"))
    d[name]=marks
print(d)
for k,v in d.items():
    print("Student Name:{} Marks:{}".format(k,v))
while True:
    name=input("Enter Your Name to check result:")
    marks=d.get(name,-1)
    if marks==-1:
        print("No data found")
    else:
        print("Student Name:{} Marks{}".format(name,marks))
    
    option=input("You want to check one more student result:[Yes/No]")
    if option.lower()=="no":
        break
print("Thank you for using my application")

output:
Enter number of students:4
Enter Name:Raja
Enter marks:80
Enter Name:Ram
Enter marks:90
Enter Name:Khan
Enter marks:70
Enter Name:Basha
Enter marks:60
{'Raja': 80, 'Ram': 90, 'Khan': 70, 'Basha': 60}
Student Name:Raja Marks:80
Student Name:Ram Marks:90
Student Name:Khan Marks:70
Student Name:Basha Marks:60
Enter Your Name to check result:Raja
Student Name:Raja Marks80
You want to check one more student result:[Yes/No]yes
Enter Your Name to check result:Khan
Student Name:Khan Marks70
You want to check one more student result:[Yes/No]yes
Enter Your Name to check result:Ram
Student Name:Ram Marks90
You want to check one more student result:[Yes/No]no
Thank you for using my application
Functions:
-----------
1.Code reusablity 
2.Performance improved

Two types of functions:
-----------------------
1.Bulitin functions:
--------------------
Eg:
	print()
	id()
	len()
	....e.t.c
2.user defined functions/customized functions:
-------------------------------------------------
Based on our requirement we define a functions

synatx:
--------
def function_name():
	'''Doc string'''
	body 
	return value
function_name()

Function parameters:
---------------------
def function_name(parameters):#formal parameters
	'''Doc string'''
	body 
	return value
function_name(parameters)  #actual parameters
eg:
def wish():
    print("Hello")
wish()
wish()
wish()
wish()

output:
Hello
Hello
Hello
Hello

return statement:
-----------------
with out return:
-----------------
eg:
def wish():
    print("Hello")
x=wish()
print(x)
output:
Hello
None

with  return:
-----------------
eg:
def wish():
    print("Hello")
    return "Good morning!"
x=wish()
print(x)

output:
Hello
Good morning!
eg:
def total():
    a=10
    b=20
    return 
x=total()
print(x)

output:
None

return multiple values:
------------------------
eg:
def calc(a,b):
    total=a+b
    sub=a-b
    mul=a*b
    div=a/b
    fdiv=a//b
    return total,sub,mul,div,fdiv
x=calc(10,20)
print(x)
print(type(x))

output:
(30, -10, 200, 0.5, 0)
<class 'tuple'>

Note: if function returns multiple values in the format of tuple.

Types of arguments:
-------------------
1. Postional arguments:
----------------------
1.order of passing arguments is important otherwise we get wrong result
2.Number of actual and formal must be same
eg:
def calc(a,b):
    return a+b,a-b
x=calc(20,10)
print(x)
y=calc(10,20)
print(y)

output:
(30, 10)
(30, -10)
eg:
def calc(a,b):
    return a+b,a-b
x=calc(20)
print(x)
output:
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    x=calc(20)
TypeError: calc() missing 1 required positional argument: 'b'
eg:
def calc(a,b):
    return a+b,a-b
x=calc(20,10,5)
print(x)
output:
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    x=calc(20,10,5)
TypeError: calc() takes 2 positional arguments but 3 were given

2.Keyword arguments:
---------------------
1.order is not important
eg:
def calc(a,b):
    return a+b,a-b
x=calc(a=20,b=10)
print(x)
output:
(30, 10)
eg:
def calc(a,b):
    return a+b,a-b
x=calc(b=10,a=20)
print(x)
output:
(30, 10)

3.default arguments:
--------------------
eg:
def wish(name):
    print("Hello",name)
wish("jagan")

output:
Hello jagan
eg:
def wish(name):
    print("Hello",name)
wish()
output:
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    wish()
TypeError: wish() missing 1 required positional argument: 'name'
eg:
def wish(name="Guest"):
    print("Hello",name)
wish("jagan")
wish()
output:
Hello jagan
Hello Guest
eg:
def wish(name="Guest"):
    if name.lower()=="jagan":
        print("Hello {} How are you".format(name))
    else:
        print("Hello",name)
wish()
wish("Ram")
wish("JAGAN")

output:
Hello Guest
Hello Ram
Hello JAGAN How are you

4.varaible length arguments:
-----------------------------
eg:
def calc(a,b):
    return a+b
x=calc(10,20)
print(x)

output:
30
eg:
def calc(a,b,c):
    return a+b+c
x=calc(10,20,30)
print(x)
output:
60
eg:
def calc(a,b,c):
    return a+b+c
x=calc(10,20)
print(x)

output:
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    x=calc(10,20)
TypeError: calc() missing 1 required positional argument: 'c'
eg:
def calc(*n):
    print(n)
    print(type(n))
calc()
calc(1)
calc(1,2)
calc(1,2,3,4,5,6,7,8)

output:
()
<class 'tuple'>
(1,)
<class 'tuple'>
(1, 2)
<class 'tuple'>
(1, 2, 3, 4, 5, 6, 7, 8)
<class 'tuple'>
eg:
def calc(*n):
    total=0
    for x in n:
        total=total+x
    print(total)
x=calc()
x=calc(1,2)
x=calc(1,2,3)

output:
0
3
6

5.varaible length key word arguments:
-------------------------------------
eg:
def f1(**n):
    print(n)
    print(type(n))
f1()
f1(a=10,b=20)
f1(a=10,b=20,c=30)

output:
{}
<class 'dict'>
{'a': 10, 'b': 20}
<class 'dict'>
{'a': 10, 'b': 20, 'c': 30}
<class 'dict'>

Types of varaibles or scope of varaibles:
------------------------------------------
1.Global varaible
2.Local varaible

1.Global varaible:
------------------
To define varaible outside of function are known as global varaible.
We can access global varaible anywhere inside of the finction

2.Local varaible:
-----------------
To define varaible inside of function are known as local varaible
we can access local varaibles only inside of the function
eg;
x=200
y=400
def f1():   
    a=10
    b=20
    c=30
    print(a)
    print(b)
    print(c)
    print(x)
    print(y)
    
print(x)
print(y)
f1()

output:
200
400
10
20
30
200
400

eg:
x=200
y=400
def f1():   
    a=10
    b=20
    c=30
    print(a)
    print(b)
    print(c)
    print(x)
    print(y)
    
print(x)
print(y)
print(a)
print(b)
print(c)
f1()
output:
200
400
Traceback (most recent call last):
  File "test.py", line 15, in <module>
    print(a)
NameError: name 'a' is not defined

eg:
x=200
y=400
def f1():
    a=10
    b=20
    print(a)
    print(b)
    print(x)
    print(y)
def f2():
    c=30
    d=40
    print(c)
    print(d)
    print(x)
    print(y)
f1()
f2()

output:
10
20
200
400
30
40
200
400
eg:
x=200
y=400
def f1():
    a=10
    b=20
    print(a)
    print(b)
    print(x)
    print(y)
def f2():
    c=30
    d=40
    print(a)
    print(c)
    print(d)
    print(x)
    print(y)
f1()
f2()
output:
10
20
200
400
Traceback (most recent call last):
  File "test.py", line 19, in <module>
    f2()
  File "test.py", line 13, in f2
    print(a)
NameError: name 'a' is not defined

global keyword:
-----------------

we can make local varaible to global varaible
eg:
x=200
y=400
def f1():
    global a
    a=10
    b=20
    print(a)
    print(b)
    print(x)
    print(y)
def f2():
    c=30
    d=40
    print(a)
    print(c)
    print(d)
    print(x)
    print(y)
f1()
f2()
output:
10
20
200
400
10
30
40
200
400

eg:
x=200
y=400
def f1():
    global a
    a=10
    b=20
    print(a)
    print(b)
    print(x)
    print(y)
def f2():
    c=30
    d=40
    print(a)
    print(c)
    print(d)
    print(x)
    print(y)
f2()
f1()
output:
Traceback (most recent call last):
  File "test.py", line 19, in <module>
    f2()
  File "test.py", line 14, in f2
    print(a)
NameError: name 'a' is not defined

Anonymous functions or lambda functions:
----------------------------------------
1.The function don't have name
2.We can use function only one time

eg:
def squre(n):
    return n*n
x=squre(4)
print(x)
output:
16

lambda function:
-----------------
eg:
d= lambda n:n*n
print(d(4))
print(d(5))

output;
16
25
eg:
d= lambda a,b:a+b
print(d(10,20))
output:
30
eg:
d= lambda a,b: a if a>b else b
print(d(2,3))
print(d(50,40))
output:
3
50

The function takes argument as an other function

1.filter(function,sequnce)
2.map(function,sequnce)
3.reduce(function,sequnce)
1.filter(function,sequnce):
----------------------------
eg:
def even(n):
    if n%2==0:
        return True
    else:
        return False
l=[1,2,3,4,5,6,7,8,9]
l1=[]
for n in l:
    if even(n):
        l1.append(n)
print(l1)

output:
[2, 4, 6, 8]

eg:
def even(n):
    if n%2==0:
        return True
    else:
        return False
l=[1,2,3,4,5,6,7,8,9]
l1=filter(even,l)
print(l1)
print(list(l1))

output:
<filter object at 0x0000024EBAD8EAC8>
[2, 4, 6, 8]
eg:
l= lambda n:n%2==0
print(l(2))
print(l(3))
output:
True
False

eg:
l=list(filter(lambda n:n%2==0,[1,2,3,4,5,6,7,8,9]))
print(l)

output:
[2, 4, 6, 8]

eg:
#input:["Ant","Bat","Dog","apple","Axe","air"]
#output:["Ant","apple","Axe","air"]
l=lambda word:word[0].upper()=="A"
print(l("Bat"))
print(l("Axe"))
print(l("ant"))
output:
False
True
True
eg:
#input:["Ant","Bat","Dog","apple","Axe","air"]
#output:["Ant","apple","Axe","air"]
l=list(filter(lambda word:word[0].upper()=="A",["Ant","Bat","Dog","apple","Axe","air"]))
print(l)
output:
['Ant', 'apple', 'Axe', 'air']

2.map(function,sequnce):
------------------------
eg:
def squre_no(n):
    return n*n
l=[1,2,3,4,5,6,7,8,9]
l1=[]
for n in l:
    l1.append(squre_no(n))
print(l1)
output:
[1, 4, 9, 16, 25, 36, 49, 64, 81]

eg:
def squre_no(n):
    return n*n
l1=map(squre_no,[1,2,3,4,5,6,7,8,9])
print(l1)
print(list(l1))

output:
<map object at 0x000002336B87E7F0>
[1, 4, 9, 16, 25, 36, 49, 64, 81]

eg:
l=list(map(lambda n:n*n,[1,2,3,4,5,6,7,8,9]))
print(l)
output:
[1, 4, 9, 16, 25, 36, 49, 64, 81]

eg:
#Input:
#l1=[1,2,3,4,5]
#l2=[10,20,30,40,50]
#output:[10,40,90,160,250]
print(list(map(lambda x,y:x*y,[1,2,3,4,5],[10,20,30,40,50])))
output:
[10, 40, 90, 160, 250]

3.reduce(function,sequnce):
---------------------------
eg:
r=reduce(lambda x,y:x+y,[1,2,3,4,5])
print(r)
output:
Traceback (most recent call last):
  File "test.py", line 1, in <module>
    r=reduce(lambda x,y:x+y,[1,2,3,4,5])
NameError: name 'reduce' is not defined

eg:
from functools import *
r=reduce(lambda x,y:x+y,[1,2,3,4,5])
print(r)
#x,y=x+y
#x=1,y=2,x+y=1+2, x+y=3----------->x=3
#x=3,y=3,x+y=3+3=6,x+y=6------->x=6
#x=6,y=4,x+y=6+4=10,x+y=10-------->x=10
#x=10,y=5,x+y=10+5=15,x+y=15------>x=15

output:
15


OPPs:
-----
1.class
2.Object
3.refference varaible


1.class:
----------
class is blue print or plan or model or design to create objects.

2.Object:
--------
Physical existance of class is nothing object.

3.refference varaible:
---------------------
The varaible which is used to reffer an object is called refference varaible
By using refference varaible we can access properties (varaibles) and actions(methods)
of object.

synatx:
--------
class Class_Name:
	'''Doc string'''
	varaible
	methods
eg:
class Student:
    '''This the class developed for student marks'''
    #variable
    #methods

print(Student.__doc__)
output:
This the class developed for student marks
eg:
class Student:
    '''This the class developed for student marks'''
    #variable
    #methods

help(Student)

output:
Help on class Student in module __main__:

class Student(builtins.object)
 |  This the class developed for student marks
 |
 |  Data descriptors defined here:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)

Inside python class three types of varaibles are allowed. 
1.Instance varaibles (object level varaibles)
2.Static varaibles (class level varaibles)
3. Local varaibles (method level varaibles)
Inside python class three types of methods are allowed
1.Instance method
2.class method
3.static method
eg:
class Student:
    """This student class"""
    def __init__ (self):
        self.name="Jagan"
        self.rollno=222
        self.marks=70

s=Student()
print(s.name)
print(s.rollno)
print(s.marks)
output:
Jagan
222
70
eg:
class Student:
    """This student class"""
    def __init__ (self):
        self.name="Jagan"
        self.rollno=222
        self.marks=70
    def info(self):
        print("Name:",self.name)
        print("RollNo:",self.rollno)
        print("Marks:",self.marks)
s1=Student()
print(s1.name)
print(s1.rollno)
print(s1.marks)

s1.info()
output:
Jagan
222
70
Name: Jagan
RollNo: 222
Marks: 70

eg:
class Student:
    def __init__(self,name,rollno,marks):
        self.name=name
        self.rollno=rollno
        self.marks=marks
    def info(self):
        print("Name:",self.name)
        print("RollNo:",self.rollno)
        print("Marks:",self.marks)
s1=Student("Jagan",222,70)
s2=Student("Ram",100,80)
s3=Student("Raj",200,90)
print(s1.name)
print(s1.rollno)
print(s1.marks)
print(s2.name)
print(s2.rollno)
print(s2.marks)
print(s3.name)
print(s3.rollno)
print(s3.marks)
s1.info()
s2.info()
s3.info()

output:
Jagan
222
70
Ram
100
80
Raj
200
90
Name: Jagan
RollNo: 222
Marks: 70
Name: Ram
RollNo: 100
Marks: 80
Name: Raj
RollNo: 200
Marks: 90

About self:
----------
self is a refference varaible which pointing to current object 

eg:
class Test:
    def __init__(self):
        pass
t=Test()

t is reffrence varaible which is pointing object from outside of class
self  is reffrence varaible which is pointing object from inside of class

eg:
class Test:
    def __init__(self):
        print("Address of object pointed by self:", id(self))
t1=Test()
print(id(t1))
t2=Test()
print(id(t2))

output:
Address of object pointed by self: 2252273478400
2252273478400
Address of object pointed by self: 2252273478512
2252273478512
eg:
class Test:
    def __init__(self):
        print("Address of object pointed by self:", id(self))
t1=Test()
print(id(t1))
t2=Test()
print(id(t2))
t3=Test()
print(id(t3))
output:
Address of object pointed by self: 2840236649384
2840236649384
Address of object pointed by self: 2840236649496
2840236649496
Address of object pointed by self: 2840236649552
2840236649552

self is first argument inside constructor ans instance method


constructor:
-----------
It is special method in python
The constructor name is always fixed __init__
When ever creating object constructor will exicuted.
For each object constructor exicuted one time.  

eg:
class Test:
    def __init__(self):
        print("Constructor")
t1=Test()
t2=Test()
t3=Test()
t4=Test()
output:
Constructor
Constructor
Constructor
Constructor   
        
The main purpose of constructor is to declare and intilize instance varaibles
eg:
class Test:
    def __init__(self,name,rollno,marks):
        self.name=name
        self.rollno=rollno
        self.marks=marks
t1=Test("Jagn",222,70) 
t2=Test("Ram",220,80)
t3=Test("Raj",400,90)        
        
print(t2.name,t2.rollno,t2.marks)
print(t1.name,t1.rollno,t1.marks)
print(t3.name,t3.rollno,t3.marks)
output:
Ram 220 80
Jagn 222 70
Raj 400 90

constructor is optional
we didn't wtrite constructor to our code python will exicute default constructor
eg:
class Test:
    def m1(self):
        print("Method1")
t1=Test()
t1.m1()
output:
C:\Users\jagan\OneDrive\Desktop\python sessions2>python test.py
Method1

eg:
class Test:
    def __init__(self):
        print("constructor")
t1=Test()
t1.__init__()

output:
constructor
constructor  

We can take more than one constructor to python code but it will exicuited only one constructor
Eg:
class Test:
    def __init__(self):
        print("constructor1")
    def __init__(self):
        print("constructor2")
    def __init__(self):
        print("constructor3")
    def __init__(self):
        print("constructor4")
t=Test()
output:
constructor4

eg:
class States:
    def __init__(self,sname,scapital):
        self.sname=sname
        self.scapital=scapital
    def info(self):
        print("State name:",self.sname)
        print("Capital Name:",self.scapital)
list_of_states=[]
while True:
    sname=input("Enter State Name:")
    scapital=input("Enter Capital Name:")
    s=States(sname,scapital)
    list_of_states.append(s)
    option=input("Do you want ente r one more state info : [Yes/No]")
    if option.lower()=="no":
        break
print(list_of_states)

for state in list_of_states:
    state.info()
    print()
output:
Enter State Name:AP
Enter Capital Name:Amarvathi
Do you want ente r one more state info : [Yes/No]yes
Enter State Name:KA
Enter Capital Name:Beng
Do you want ente r one more state info : [Yes/No]yes
Enter State Name:TS
Enter Capital Name:Hyd
Do you want ente r one more state info : [Yes/No]yes
Enter State Name:TN
Enter Capital Name:chennai
Do you want ente r one more state info : [Yes/No]no
[<__main__.States object at 0x00000220F31EEB38>, <__main__.States object at 0x00000220F31EEC18>, <__main__.States object at 0x00000220F31EEBE0>, <__main__.States object at 0x00000220F31EECC0>]
State name: AP
Capital Name: Amarvathi

State name: KA
Capital Name: Beng

State name: TS
Capital Name: Hyd

State name: TN
Capital Name: chennai
    
Inside python class three types of varaibles are allowed 

1.Instance varaibles (object level varaibles)
2.Static varaibles (class level varaibles)
3. Local varaibles (method level varaibles)
        
 
1.Instance varaibles (object level varaibles):
----------------------------------------------
The varaible which are varied from object to object are known as Instance varaibles.
Eg:
	 name,rollno
Every object having separate instance varaibles
To declare instance varaibles inside constructor or inside instance method.
eg:
class Student:
    def __init__(self,name,rollno,marks):
        self.name=name
        self.rollno=rollno
        self.marks=marks
    def grade(self):
        self.grade="A"
t1=Student("jagan",222,70)

2.Static varaibles (class level varaibles):
-------------------------------------------
The variable which are same for every object or the varaible which are not changeing from
object to objec such type of varaibles we can take it as static varaibles.
eg:
class Student:
    college_name="Govt College"
    def __init__(self,name,rollno,marks):
        self.name=name
        self.rollno=rollno
        self.marks=marks
    def info(self):
        print("Name:",self.name)
        print("Rollno:",self.rollno)
        print("Marks:",self.marks)
        print("College Name:",Student.college_name)
s1=Student("Jagan",222,70)
s2=Student("Raj",210,90)
s1.info()
s2.info()

output:
Name: Jagan
Rollno: 222
Marks: 70
College Name: Govt College
Name: Raj
Rollno: 210
Marks: 90
College Name: Govt College

3. Local varaibles (method level varaibles):
---------------------------------------------
The varaibles which are used to meet temporry requirements such type of variables 
are known as loca varaibles.
eg:
class Student:
    def info(self):
        x=10
        for y in range(10):
            print(y)
s1=Student()
s1.info()

output:
0
1
2
3
4
5
6
7
8
9
Inside python class three types of methods are allowed
1.Instance method
2.class method
3.static method
1.Instance method:
-----------------
Inside instance method we are accessing instance varaibles and the method allways talks about
perticular object only.
The first instance method is self.
eg:
class Test:
    def m1(self):
        self.name=name  
        print(self.name)
2.class method:
---------------
Inside method we can access the only class level varaibles or static level varaibles we can go for
class method.
class method declared by using @classmethod decarator
The first argument to the class method is cls.
cls is varaible
eg:
class Test:
    school_name="ABCD School"
    @classmethod
    def m1(cls):
        print("School Name:",cls.school_name)
        print("School Name:",Test.school_name)
t1=Test()
t1.m1()
out:
School Name: ABCD School
School Name: ABCD School

eg:
class Test:
    school_name="ABCD School"
    @classmethod
    def m1(cls):
        print(id(cls))
        print("School Name:",cls.school_name)
        print("School Name:",Test.school_name)
t1=Test()
t1.m1()
print(id(Test))

output:
1907016357656
School Name: ABCD School
School Name: ABCD School
1907016357656

3.static method:
------------------
Inside static method if not using any object level or class level information we 
can go for static method.

static method declare dusing @staticmethod decarator
eg:
class Test:
    @staticmethod
    def sum(a,b):
        return a+b
t1=Test()
print(t1.sum(10,20))

output:
30
eg:
class Student:
    schoo_name="ABCD School"
    def __init__(self,name,marks):
        self.name=name
        self.marks=marks
    def getinfo(self):
        print("Name:",self.name)
        print("Marks:",self.marks)
    @classmethod
    def get_school(cls):
        print("School Name:",cls.schoo_name)
    @staticmethod
    def sum(a,b):
        return a+b
s1=Student("Jagan",70)
s1.getinfo()
s1.get_school()
print(s1.sum(90,10))

output:
Name: Jagan
Marks: 70
School Name: ABCD School
100
eg:
class Bank:
    bank_name="ABCD Bank"
    def __init__(self,name,balance=0.0):
        self.name=name
        self.balance=balance
    def deposit(self,ammount):
        self.balance=self.balance+ammount
        print("After deposit Ammont:",self.balance)
    def withdraw(self,ammount):
        if ammount>self.balance:
            print("Insufficent fund")
        else:
            self.balance=self.balance-ammount
            print("After withdraw Ammont:",self.balance)
print("Welcome to:",Bank.bank_name)
name=input("Enter your Name:")
b=Bank(name)
while True:
    print("""D-Deposit
    W -Withdraw
    E-Exit""")
    option=input("Enter your option:")
    if option.lower()=="d":
        ammount=float(input("Enter your ammount:"))
        b.deposit(ammount)
    elif option.lower()=="w":
        ammount=float(input("Enter your ammount:"))
        b.withdraw(ammount)
    elif option.lower()=="e":
        print("Thank for Banking")
        break
    else:
        print("Your entetered option invalid")
output:
Welcome to: ABCD Bank
Enter your Name:jagan
D-Deposit
    W -Withdraw
    E-Exit
Enter your option:D
Enter your ammount:1000
After deposit Ammont: 1000.0
D-Deposit
    W -Withdraw
    E-Exit
Enter your option:D
Enter your ammount:500
After deposit Ammont: 1500.0
D-Deposit
    W -Withdraw
    E-Exit
Enter your option:w
Enter your ammount:1000
After withdraw Ammont: 500.0
D-Deposit
    W -Withdraw
    E-Exit
Enter your option:w
Enter your ammount:5000
Insufficent fund
D-Deposit
    W -Withdraw
    E-Exit
Enter your option:D
Enter your ammount:1200
After deposit Ammont: 1700.0
D-Deposit
    W -Withdraw
    E-Exit
Enter your option:R
Your entetered option invalid
D-Deposit
    W -Withdraw
    E-Exit
Enter your option:E
Thank for Banking

Garbage collector:
-----------------
Object does not having any refference varaibles such type of objects deleted by GC
eg:
import gc
print(gc.isenabled())
gc.disable()
print(gc.isenabled())
gc.enable()
print(gc.isenabled())

output:
True
False
True

Destructor:
-----------
Destructor is a special method in python and name of destructor is __del__()
Just before destroying object GC calls the destructor to perform any cleanup
activities ,Once destructor exicution completed gc destroy object.
eg:
class Test :
    def __init__(self):
        print("Object Creation")
    def __del__(self):
        print("clean up activities")
t=Test()
t=None

output:
Object Creation
clean up activities
eg:
class Test :
    def __init__(self):
        print("Object Creation")
    def __del__(self):
        print("clean up activities")
t1=Test()
t2=Test()

output:
Object Creation
Object Creation
clean up activities
clean up activities
eg:
class Test :
    def __init__(self):
        print("Object Creation")
    def __del__(self):
        print("clean up activities")
l=[Test(),Test(),Test(),Test(),Test(),Test(),Test(),Test(),Test()]
outut:
Object Creation
Object Creation
Object Creation
Object Creation
Object Creation
Object Creation
Object Creation
Object Creation
Object Creation
clean up activities
clean up activities
clean up activities
clean up activities
clean up activities
clean up activities
clean up activities
clean up activities
clean up activities

Inhertance:
----------
The concept of inheting members from one class to another class is known inhertance.


1.single inhertance
2.multilevel inhertance
3.Hireachial inhertance
4.multiple inhertance
5.Hybrid inhertance
6.cyclic inhertance

1.single inhertance:
--------------------
The concept of inheting members from one class to another class is known inhertance.
eg:
class P:
    def m1(self):
        print("Land+House+Car")
        
class C:
    def m2(sef):
        print("Bike")
c=C()
c.m2()
c.m1()

output:
Bike
Traceback (most recent call last):
  File "test.py", line 10, in <module>
    c.m1()
AttributeError: 'C' object has no attribute 'm1'

eg:
class P:
    def m1(self):
        print("Land+House+Car")
        
class C(P):
    def m2(sef):
        print("Bike")
c=C()
c.m2()
c.m1()

output:
Bike
Land+House+Car

2.multilevel inhertance:
-------------------------
The concept of inheting members from multiple class to single class is known inhertance.
eg:
class GP:
    def m1(self):
        print("House+Land")
class P(GP):
    def m2(self):
        print("Shop+car")
class C(P):
    def m3(self):
        print("Bicycle")
c=C()
c.m3()
c.m2()
c.m1()

output:
Bicycle
Shop+car
House+Land

3.Hireachial inhertance:
---------------------------
The concept of inheting members from one class to multiple class which are present at same level 
  is known Hireachial inhertance.
  
  eg:
class P:
    def m1(self):
        print("Parent class m1 method")
class C1(P):
    def m2(self):
        print("C1 m2 method")
class C2(P):
    def m3(self):
        print("C2 m3 method")
c1=C1()
c2=C2()
c1.m2()
c1.m1()
c2.m3()
c2.m1()

output:
C1 m2 method
Parent class m1 method
C2 m3 method
Parent class m1 method

4.multiple inhertance:
------------------------
It revese of hirachial inhertance
The concept of inherting members from mutiple class to single class is 
known as multilevel inhertance.
eg:
class P1:
    def m1(self):
        print("p1   m1")
class P2:
    def m2(self):
        print("p2  m2")
class C(P1,P2):
    def m3(self):
        print("c1 m3")
c=C()
c.m3()
c.m2()
c.m1()
output:
c1 m3
p2  m2
p1   m1

5.Hybrid inhertance:
-----------------------
Hybrid inhertance is a combination of single,multiple, multilvel and hirachial inhertance.

Note:
	In hybrid inhertance method seraching based on MRO(<ethod Resoloution Order) algorithum.
6.cyclic inhertance:
--------------------
The concept of inherting members from one class to another class in cyclic way is cyclic
inhertance.

Note:
 cyclic inhertance doesn't supports python
eg:
class A(B):
    def m1(self):
        pass
class B(A):
    def m2(self):
        pass        
b=B() 

output:
Traceback (most recent call last):
  File "test.py", line 1, in <module>
    class A(B):
NameError: name 'B' is not defined       


super():
--------
eg:
class P:
    def m1(self):
        print("Parent class m1 method")
class C(P):
    def m2(self):
        print("C1 m2 method")
c=C()
c.m2()
c.m1()

output:
C1 m2 method
Parent class m1 method
eg:
class P:
    def m1(self):
        print("Parent class m1 method")
class C(P):
    def m1(self):
        print("C1 m1 method")
c=C()
c.m1()

output:
C1 m1 method
eg:
class P:
    def m1(self):
        print("Parent class m1 method")
class C(P):
    def m1(self):
        super().m1()
        print("C1 m1 method")
c=C()
c.m1()

output:
Parent class m1 method
C1 m1 method

eg:
class P:
   def __init__(self):
        print("Parent class constructor")
class C(P):
    def __init__(self):
        super().__init__()
        print("child class constructor")
c=C()
output:
Parent class constructor
child class constructor
Polymorphisum:
-------------
poly means many and morphs means forms

polymorohisum is nothing but many forms.

operator overloading:
--------------------
+ and * operator:
-------------------
eg:
print(10+20)
print("Hello"+"World")

print(2*2)
print("Hello"*2)

output:
30
HelloWorld
4
HelloHello


method overriding:
-------------------
eg:
class Book:
    def __init__(self,pages):
        self.pages=pages
b1=Book(10)
print(type(b1))
b2=Book(20)
print(type(b2))
print(b1+b2)

output:
<class '__main__.Book'>
<class '__main__.Book'>
Traceback (most recent call last):
  File "test.py", line 8, in <module>
    print(b1+b2)
TypeError: unsupported operand type(s) for +: 'Book' and 'Book'

Magical methods:
--------------
Every operator internally having one magical method.when ever operator exicuited 
internally coresponding magical method is also exicuted.


For + operator magical method is __add__()
For - operator magical method is __sub__()

eg:
class Book:
    def __init__(self,pages):
        self.pages=pages
    def __add__(self,other):
        totalpages=self.pages+other.pages
        return totalpages
        
        
        
b1=Book(10)
print(type(b1))
b2=Book(20)
print(type(b2))
print(b1+b2)

output:
<class '__main__.Book'>
<class '__main__.Book'>
30
eg:
class Book:
    def __init__(self,pages):
        self.pages=pages
    def __sub__(self,other):
        difference=self.pages - other.pages
        return difference

        
        
        
b1=Book(10)
print(type(b1))
b2=Book(20)
print(type(b2))
print(b1-b2)

output:
<class '__main__.Book'>
<class '__main__.Book'>
-10
magical methods are
---------------------
+  --------   __add__()
- ----------  __sub__()
* ---------  __mul__()
/ ---------- __div__()
// ---------  __floordiv__()
% ----------  __mod__()
**  ---------  __pow__()
< -------   __lt__()
<=  --------  __le__()
> ----------  __gt__()
>= ---------  __ge__()
== --------   __eq__()
! --------   __ne__()

eg:
class Student:
    def __init__(self,name,marks):
        self.name=name
        self.marks=marks
    def __gt__(self,other):
        return self.marks > other.marks
    def __lt__(self,other):
        return self.marks < other.marks      
    
    
s1=Student("Ram",80)
s2=Student("Raj",70)
print(s1>s2)
print(s1<s2)
output:
True
False

method overloading:
--------------------
Method name is same but it is taking multiple number of arguments

Note: Method overloading concept not support python.
eg:
class Test:
    def m1(self):
        print("Zero arguments")
    def m1(self,x):
        print("one arguments")
    def m1(self,x,y):
        print("two arguments")
t=Test()
t.m1()

output:
Traceback (most recent call last):
  File "test.py", line 9, in <module>
    t.m1()
TypeError: m1() missing 2 required positional arguments: 'x' and 'y'

eg:
class Test:
    def m1(self):
        print("Zero arguments")
    def m1(self,x):
        print("one arguments")
    def m1(self,x,y):
        print("two arguments")
t=Test()
t.m1(10,20)
output:
two arguments

eg:
class Test:
    def m1(self):
        print("Zero arguments")
    def m1(self,x):
        print("one arguments")
    def m1(self,x,y):
        print("two arguments")
t=Test()
t.m1(10,20)
output:
two arguments

method over rididing:
----------------------
What ever methods present in parent class are by default available to child class 
through inhertance.

some times child class not satisfy with parent class methods then child class define their own methods.
eg:
class P:
    def property(self):
        print("Land"+"cash")
    def vehicle(self):
        print("Tvs")
class C(P):
    pass
c=C()
c.property()
c.vehicle()
output:
Landcash
Tvs
eg:
class P:
    def property(self):
        print("Land"+"cash")
    def vehicle(self):
        print("Tvs")
class C(P):
    def vehicle(self):
        print("RoyalEnfiled")
c=C()
c.property()
c.vehicle()
output:
Landcash
RoyalEnfiled
        

Data hiding:
------------       

Outside person can't access our internal data directly and data doesn't go to outside directly.
        
eg:
class Account:
    def __init__(self,balance):
        self.balance=balance
a=Account(1000)
print(a.balance)
output:
1000
eg:
class Account:
    def __init__(self,balance):
        self.__balance=balance
a=Account(1000)
print(a.__balance)
output:
Traceback (most recent call last):
  File "test.py", line 5, in <module>
    print(a.__balance)
AttributeError: 'Account' object has no attribute '__balance'
eg:
class Account:
    def __init__(self,balance):
        self.__balance=balance
    def getbalance(self):
        return self.__balance
a=Account(10000)
print(a.getbalance())
output:
10000

Abstraction:
------------
eg:
class Account:
    def __init__(self):
        pass
    def getbalance(self):
        pass
    def m1(self):
        pass
a=Account()


Enacapulation:
--------------
Enacapulation=Data hiding+Abstraction

Three pillars of opps:
-----------------------
1.Inhertance ---------- code reusablity
2.Polymorphisum -------- Flexibilty
3.Enacapulation --------- security

Exception handling:
------------------
In any programing langugae two types of errors are possible
1.syntax error
2.Runtime error or logical error

1.syntax error:
--------------
if doing any mistake at coding level such type of errors are known as synatx errors.
eg:
x=10
if x==10
    print("hello")
output:
  File "test.py", line 2
    if x==10
           ^
SyntaxError: invalid syntax

2.Runtime error or logical error:
-------------------------------
Exception handling concept talks about run time errors only.
if exicution of any program something goes wrong because of end user input or program error
or memoery error e.t.c.In this situations errors are raised.These errors are known as 
Runtime error or logical error.
eg:
print(10/0)
output:
Traceback (most recent call last):
  File "test.py", line 1, in <module>
    print(10/0)
ZeroDivisionError: division by zero

what is exception:
------------------
while exicuting the program something goes wrong which is distrub the normal flow the program
is nothing but exception.
eg:
ZeroDivisionError
TypeError
ValueError
e.t.c
what is need of exception handling:
---------------------------------
Need of exception handling is normal or graceful termination of the program.

what is meaning of exception handling:
--------------------------------------
It means that defining alternate way to continue rest of program.

syntax:
--------
try:
   ----------
   -------------
except:
     --------------
	 --------------
finally:
     ---------
	 ----------------
	 
	 
try:
-----
 Risky code ---------->The code may be maynot be raise any error.
 
except:
-------
	alternatative code
finally:
-------
	cleanup code --------->This block of executed always.
eg:
try:
    print("Hello")
    print("Hello")
    print("Hello")
except:
    print("Handling code")
finally:
    print("cleanup code")
ouutput:
Hello
Hello
Hello
cleanup code
eg:
try:
    print("Hello")
    print(10/0)
except:
    print("Handling code")
finally:
    print("cleanup code")
output:
Hello
Handling code
cleanup code
eg:
try:
    print("Hello")
    print(10/0)
except ZeroDivisionError:
    print("Handling code")
finally:
    print("cleanup code")
output:
Hello
Handling code
cleanup code
eg:
try:
    print("Hello")
    print(int("Hello"))
except ZeroDivisionError:
    print("Handling code")
finally:
    print("cleanup code")
output:
Hello
cleanup code
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    print(int("Hello"))
ValueError: invalid literal for int() with base 10: 'Hello'
eg:
try:
    print("Hello")
    print(int("Hello"))
except ZeroDivisionError:
    print("ZeroDivisionError Handling code")
except ValueError:
    print("ValueError Handling code")
finally:
    print("cleanup code")
output:
Hello
ValueError Handling code
cleanup code
eg:
try:
    print("Hello")
    print(10/0)
except ZeroDivisionError:
    print("ZeroDivisionError Handling code")
except ValueError:
    print("ValueError Handling code")
finally:
    print("cleanup code")
output:
Hello
ZeroDivisionError Handling code
cleanup code
eg:
try:
    print("Hello")
    print(int(10+20j))
except ZeroDivisionError:
    print("ZeroDivisionError Handling code")
except ValueError:
    print("ValueError Handling code")
finally:
    print("cleanup code")
output:
Hello
cleanup code
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    print(int(10+20j))
TypeError: can't convert complex to int

eg:
try:
    print("Hello")
    print(int(10+20j))
except ZeroDivisionError:
    print("ZeroDivisionError Handling code")
except ValueError:
    print("ValueError Handling code")
except:
    print("all errors ")
    
finally:
    print("cleanup code")
output:
Hello
all errors
cleanup code
eg:
try:
    print("Hello")
    print(10/0)
except:
    print("all errors ")
except ZeroDivisionError:
    print("ZeroDivisionError Handling code")
except ValueError:
    print("ValueError Handling code") 
finally:
    print("cleanup code")
output:
  File "test.py", line 3
    print(10/0)
            ^
SyntaxError: default 'except:' must be last

Note: default except block we can take at last only.
eg:
try:
    print("Hello")
    print(10/0)

except ZeroDivisionError:
    print("ZeroDivisionError Handling code")
except ValueError:
    print("ValueError Handling code") 
except:
    print("all errors ")
finally:
    print("cleanup code")
output:
Hello
ZeroDivisionError Handling code
cleanup code
eg:
try:
    print("Hello")
except:
    print("Except handle")
else:
    print("else block")
finally:
    print("Cleanup code")
output:
Hello
else block
Cleanup code
eg:
try:
    print("Hello")
    print(10/0)
except:
    print("Except handle")
else:
    print("else block")
finally:
    print("Cleanup code")
output:
Hello
Except handle
Cleanup code

Note:
------
if any exception raised in try block then except block exicuited but else not executed.
if no exception in try block then except block not exicuted then else block exicuted.